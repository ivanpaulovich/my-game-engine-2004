<html>
<head>
<title>brSprite.html</title>
</head>
<!-- Generated by SynEdit HTML exporter -->
<body text="#000000" bgcolor="#FFFFFF">
<pre>
<code><font  size=3 face="Courier New"><font color="#000080"><i>(*******************************************************)
(*                                                     *)
(*       Engine Paulovich DirectX                      *)
(*       Win32-DirectX API Unit                        *)
(*                                                     *)
(*       Copyright (c) 2003-2004, Ivan Paulovich       *)
(*                                                     *)
(*       iskatrek@hotmail.com  uin#89160524            *)
(*                                                     *)
(*       Unit: brSprite                                *)
(*                                                     *)
(*******************************************************)

</i></font><b>unit </b>brSprite;

<b>interface

uses
  </b>Windows, SysUtils, Classes, brGraphics,
  D3DX8, <font color="#000080"><i>{$IFDEF DXG_COMPAT}</i></font>DirectXGraphics<font color="#000080"><i>{$ELSE}</i></font>Direct3D8<font color="#000080"><i>{$ENDIF}</i></font>;

<b>type

  </b><font color="#000080"><i>(* TSprite *)

  </i></font>TSpriteEngine = <b>class</b>;

  TSprite = <b>class
  private
    </b>FEngine: TSpriteEngine;
    FParent: TSprite;
    FList: TList;
    FDeaded: Boolean;
    FDrawList: TList;
    FCollisioned: Boolean;
    FMoved: Boolean;
    FVisible: Boolean;
    FX: Single;
    FY: Single;
    FZ: Integer;
    FWidth: Integer;
    FHeight: Integer;
    <b>procedure </b>Add(Sprite: TSprite);
    <b>procedure </b>Remove(Sprite: TSprite);
    <b>procedure </b>AddDrawList(Sprite: TSprite);
    <b>procedure </b>Collision2;
    <b>procedure </b>Draw;
    <b>function </b>GetClientRect: TRect;
    <b>function </b>GetCount: Integer;
    <b>function </b>GetItem(Index: Integer): TSprite;
    <b>function </b>GetWorldX: Single;
    <b>function </b>GetWorldY: Single;
    <b>procedure </b>SetZ(Value: Integer);
  <b>protected
    procedure </b>DoCollision(Sprite: TSprite; <b>var </b>Done: Boolean); <b>virtual</b>;
    <b>procedure </b>DoDraw; <b>virtual</b>;
    <b>procedure </b>DoMove(MoveCount: Integer); <b>virtual</b>;
    <b>function </b>GetBoundsRect: TRect; <b>virtual</b>;
    <b>function </b>TestCollision(Sprite: TSprite): Boolean; <b>virtual</b>;
  <b>public
    constructor </b>Create(AParent: TSprite); <b>virtual</b>;
    <b>destructor </b>Destroy; <b>override</b>;
    <b>procedure </b>Clear;
    <b>function </b>Collision: Integer;
    <b>procedure </b>Dead;
    <b>procedure </b>Move(MoveCount: Integer);
    <b>function </b>GetSpriteAt(X, Y: Integer): TSprite;
    <b>property </b>BoundsRect: TRect <b>read </b>GetBoundsRect;
    <b>property </b>ClientRect: TRect <b>read </b>GetClientRect;
    <b>property </b>Collisioned: Boolean <b>read </b>FCollisioned <b>write </b>FCollisioned;
    <b>property </b>Count: Integer <b>read </b>GetCount;
    <b>property </b>Engine: TSpriteEngine <b>read </b>FEngine;
    <b>property </b>Items[<b>Index</b>: Integer]: TSprite <b>read </b>GetItem; <b>default</b>;
    <b>property </b>Moved: Boolean <b>read </b>FMoved <b>write </b>FMoved;
    <b>property </b>Parent: TSprite <b>read </b>FParent;
    <b>property </b>Visible: Boolean <b>read </b>FVisible <b>write </b>FVisible;
    <b>property </b>Width: Integer <b>read </b>FWidth <b>write </b>FWidth;
    <b>property </b>WorldX: Single <b>read </b>GetWorldX;
    <b>property </b>WorldY: Single <b>read </b>GetWorldY;
    <b>property </b>Height: Integer <b>read </b>FHeight <b>write </b>FHeight;
    <b>property </b>X: Single <b>read </b>FX <b>write </b>FX;
    <b>property </b>Y: Single <b>read </b>FY <b>write </b>FY;
    <b>property </b>Z: Integer <b>read </b>FZ <b>write </b>SetZ;
  <b>end</b>;

  <font color="#000080"><i>(* TSpriteEngine *)

  </i></font>TSpriteEngine = <b>class</b>(TSprite)
  <b>private
    </b>FAllCount: Integer;
    FCollisionCount: Integer;
    FCollisionDone: Boolean;
    FCollisionRect: TRect;
    FCollisionSprite: TSprite;
    FDeadList: TList;
    FDrawCount: Integer;
    FSurfaceRect: TRect;
    <b>procedure </b>SetSurface(Value: TRect);
  <b>public
    constructor </b>Create(AParent: TSprite); <b>override</b>;
    <b>destructor </b>Destroy; <b>override</b>;
    <b>procedure </b>Dead;
    <b>procedure </b>Draw;
    <b>property </b>AllCount: Integer <b>read </b>FAllCount;
    <b>property </b>DrawCount: Integer <b>read </b>FDrawCount;
    <b>property </b>SurfaceRect: TRect <b>read </b>FSurfaceRect <b>write </b>SetSurface;
  <b>end</b>;

  <font color="#000080"><i>{  TBackgroundSprite  }

  </i></font>TBackgroundSprite = <b>class</b>(TSprite)
  <b>private
    </b>FImage: TPicture;
    FCollisionMap: Pointer;
    FMap: Pointer;
    FMapWidth: Integer;
    FMapHeight: Integer;
    FTile: Boolean;
    <b>function </b>GetCollisionMapItem(X, Y: Integer): Boolean;
    <b>function </b>GetChip(X, Y: Integer): Integer;
    <b>procedure </b>SetChip(X, Y: Integer; Value: Integer);
    <b>procedure </b>SetCollisionMapItem(X, Y: Integer; Value: Boolean);
    <b>procedure </b>SetMapHeight(Value: Integer);
    <b>procedure </b>SetMapWidth(Value: Integer);
  <b>protected
    procedure </b>DoDraw; <b>override</b>;
    <b>function </b>GetBoundsRect: TRect; <b>override</b>;
    <b>function </b>TestCollision(Sprite: TSprite): Boolean; <b>override</b>;
  <b>public
    constructor </b>Create(AParent: TSprite); <b>override</b>;
    <b>destructor </b>Destroy; <b>override</b>;
    <b>procedure </b>SetMapSize(AMapWidth, AMapHeight: Integer);
    <b>property </b>Chips[X, Y: Integer]: Integer <b>read </b>GetChip <b>write </b>SetChip;
    <b>property </b>CollisionMap[X, Y: Integer]: Boolean <b>read </b>GetCollisionMapItem <b>write </b>SetCollisionMapItem;
    <b>property </b>Image: TPicture <b>read </b>FImage <b>write </b>FImage;
    <b>property </b>MapHeight: Integer <b>read </b>FMapHeight <b>write </b>SetMapHeight;
    <b>property </b>MapWidth: Integer <b>read </b>FMapWidth <b>write </b>SetMapWidth;
    <b>property </b>Tile: Boolean <b>read </b>FTile <b>write </b>FTile;
  <b>end</b>;

  <font color="#000080"><i>{  TImageSprite  }

  </i></font>TImageSprite = <b>class</b>(TSprite)
  <b>private
    </b>FAnimCount: Integer;
    FAnimLooped: Boolean;
    FAnimPos: Double;
    FAnimSpeed: Double;
    FAnimStart: Integer;
    FAnimReverse: Boolean;
    FImage: TPicture;
    FPixelCheck: Boolean;
    FTile: Boolean;
    FTransparent: Boolean;
    FAlpha: Byte;
    FAngle: Single;
    FScale: TD3DXVector2;
    FCenter: TD3DXVector2;
    FShadow: Boolean;
    FShadowX: Single;
    FShadowY: Single;
    FShadowAlpha: Byte;
    FShadowScale: TD3DXVector2;
    <b>function </b>GetDrawImageIndex: Integer;
    <b>function </b>GetDrawRect: TRect;
  <b>protected
    procedure </b>DoDraw; <b>override</b>;
    <b>procedure </b>DoMove(MoveCount: Integer); <b>override</b>;
    <b>function </b>GetBoundsRect: TRect; <b>override</b>;
    <b>function </b>TestCollision(Sprite: TSprite): Boolean; <b>override</b>;
  <b>public
    constructor </b>Create(AParent: TSprite); <b>override</b>;
    <b>property </b>AnimCount: Integer <b>read </b>FAnimCount <b>write </b>FAnimCount;
    <b>property </b>AnimLooped: Boolean <b>read </b>FAnimLooped <b>write </b>FAnimLooped;
    <b>property </b>AnimPos: Double <b>read </b>FAnimPos <b>write </b>FAnimPos;
    <b>property </b>AnimSpeed: Double <b>read </b>FAnimSpeed <b>write </b>FAnimSpeed;
    <b>property </b>AnimStart: Integer <b>read </b>FAnimStart <b>write </b>FAnimStart;
    <b>property </b>AnimReverse: Boolean <b>read </b>FAnimReverse <b>write </b>FAnimReverse;
    <b>property </b>PixelCheck: Boolean <b>read </b>FPixelCheck <b>write </b>FPixelCheck;
    <b>property </b>Image: TPicture <b>read </b>FImage <b>write </b>FImage;
    <b>property </b>Tile: Boolean <b>read </b>FTile <b>write </b>FTile;
    <b>property </b>Alpha: Byte <b>read </b>FAlpha <b>write </b>FAlpha;
    <b>property </b>Scale: TD3DXVector2 <b>read </b>FScale <b>write </b>FScale;
    <b>property </b>Angle: Single <b>read </b>FAngle <b>write </b>FAngle;
    <b>property </b>Center: TD3DXVector2 <b>read </b>FCenter <b>write </b>FCenter;
    <b>property </b>Shadow: Boolean <b>read </b>FShadow <b>write </b>FShadow;
    <b>property </b>ShadowX: Single <b>read </b>FShadowX <b>write </b>FShadowX;
    <b>property </b>ShadowY: Single <b>read </b>FShadowY <b>write </b>FShadowY;
    <b>property </b>ShadowAlpha: Byte <b>read </b>FShadowAlpha <b>write </b>FShadowAlpha;
    <b>property </b>ShadowScale: TD3DXVector2 <b>read </b>FShadowScale <b>write </b>FShadowScale;
  <b>end</b>;

<b>implementation

uses
  </b>brForms, brUtils;

<b>function </b>Mod2(i, i2: Integer): Integer;
<b>begin
  </b>Result := i <b>mod </b>i2;
  <b>if </b>Result &lt; <font color="#000080">0 </font><b>then
    </b>Result := i2 + Result;
<b>end</b>;

<b>function </b>Mod2f(i: Double; i2: Integer): Double;
<b>begin
  if </b>i2 = <font color="#000080">0 </font><b>then
    </b>Result := i
  <b>else
  begin
    </b>Result := i - Trunc(i / i2) * i2;
    <b>if </b>Result &lt; <font color="#000080">0 </font><b>then
      </b>Result := i2 + Result;
  <b>end</b>;
<b>end</b>;

  <font color="#000080"><i>(* TSprite *)

</i></font><b>constructor </b>TSprite.Create(AParent: TSprite);
<b>begin
  inherited </b>Create;
  FParent := AParent;
  <b>if </b>FParent &lt;&gt; <b>nil then
  begin
    </b>FParent.Add(Self);
    <b>if </b>FParent <b>is </b>TSpriteEngine <b>then
      </b>FEngine := TSpriteEngine(FParent)
    <b>else
      </b>FEngine := FParent.Engine;
    Inc(FEngine.FAllCount);
  <b>end</b>;

  FCollisioned := True;
  FMoved := True;
  FVisible := True;
<b>end</b>;

<b>destructor </b>TSprite.Destroy;
<b>begin
  </b>Clear;
  <b>if </b>FParent &lt;&gt; <b>nil then
  begin
    </b>Dec(FEngine.FAllCount);
    FParent.Remove(Self);
    FEngine.FDeadList.Remove(Self);
  <b>end</b>;
  FList.Free;
  FDrawList.Free;
  <b>inherited </b>Destroy;
<b>end</b>;

<b>procedure </b>TSprite.Add(Sprite: TSprite);
<b>begin
  if </b>FList = <b>nil then
  begin
    </b>FList := TList.Create;
    FDrawList := TList.Create;
  <b>end</b>;
  FList.Add(Sprite);
  AddDrawList(Sprite);
<b>end</b>;

<b>procedure </b>TSprite.Remove(Sprite: TSprite);
<b>begin
  </b>FList.Remove(Sprite);
  FDrawList.Remove(Sprite);
  <b>if </b>FList.Count = <font color="#000080">0 </font><b>then
  begin
    </b>FList.Free;
    FList := <b>nil</b>;
    FDrawList.Free;
    FDrawList := <b>nil</b>;
  <b>end</b>;
<b>end</b>;

<b>procedure </b>TSprite.AddDrawList(Sprite: TSprite);
<b>var
  </b>L, H, I, C: Integer;
<b>begin
  </b>L := <font color="#000080">0</font>;
  H := FDrawList.Count - <font color="#000080">1</font>;
  <b>while </b>L &lt;= H <b>do
  begin
    </b>I := (L + H) <b>div </b><font color="#000080">2</font>;
    C := TSprite(FDrawList[I]).Z - Sprite.Z;
    <b>if </b>C &lt; <font color="#000080">0 </font><b>then </b>L := I + <font color="#000080">1 </font><b>else
      </b>H := I - <font color="#000080">1</font>;
  <b>end</b>;
  FDrawList.Insert(L, Sprite);
<b>end</b>;

<b>procedure </b>TSprite.Clear;
<b>begin
  while </b>Count &gt; <font color="#000080">0 </font><b>do
    </b>Items[Count - <font color="#000080">1</font>].Free;
<b>end</b>;

<b>function </b>TSprite.Collision: Integer;
<b>var
  </b>i: Integer;
<b>begin
  </b>Result := <font color="#000080">0</font>;
  <b>if </b>(FEngine &lt;&gt; <b>nil</b>) <b>and </b>(<b>not </b>FDeaded) <b>and </b>(Collisioned) <b>then
  begin
    with </b>FEngine <b>do
    begin
      </b>FCollisionCount := <font color="#000080">0</font>;
      FCollisionDone := False;
      FCollisionRect := Self.BoundsRect;
      FCollisionSprite := Self;

      <b>for </b>i := <font color="#000080">0 </font><b>to </b>Count - <font color="#000080">1 </font><b>do
        </b>Items[i].Collision2;

      Result := FCollisionCount;
    <b>end</b>;
  <b>end</b>;
<b>end</b>;

<b>procedure </b>TSprite.Collision2;
<b>var
  </b>i: Integer;
<b>begin
  if </b>Collisioned <b>then
  begin
    if </b>(Self &lt;&gt; FEngine.FCollisionSprite) <b>and </b>OverlapRect(BoundsRect, FEngine.FCollisionRect) <b>and
      </b>FEngine.FCollisionSprite.TestCollision(Self) <b>and </b>TestCollision(FEngine.FCollisionSprite) <b>then
    begin
      </b>Inc(FEngine.FCollisionCount);
      FEngine.FCollisionSprite.DoCollision(Self, FEngine.FCollisionDone);
      <b>if </b>(<b>not </b>FEngine.FCollisionSprite.Collisioned) <b>or </b>(FEngine.FCollisionSprite.FDeaded) <b>then
      begin
        </b>FEngine.FCollisionDone := True;
      <b>end</b>;
    <b>end</b>;
    <b>if </b>FEngine.FCollisionDone <b>then </b>Exit;
    <b>for </b>i := <font color="#000080">0 </font><b>to </b>Count - <font color="#000080">1 </font><b>do
      </b>Items[i].Collision2;
  <b>end</b>;
<b>end</b>;

<b>procedure </b>TSprite.Dead;
<b>begin
  if </b>(FEngine &lt;&gt; <b>nil</b>) <b>and </b>(<b>not </b>FDeaded) <b>then
  begin
    </b>FDeaded := True;
    FEngine.FDeadList.Add(Self);
  <b>end</b>;
<b>end</b>;

<b>procedure </b>TSprite.DoMove;
<b>begin

end</b>;

<b>procedure </b>TSprite.DoDraw;
<b>begin

end</b>;

<b>procedure </b>TSprite.DoCollision(Sprite: TSprite; <b>var </b>Done: Boolean);
<b>begin

end</b>;

<b>function </b>TSprite.TestCollision(Sprite: TSprite): Boolean;
<b>begin
  </b>Result := True;
<b>end</b>;

<b>procedure </b>TSprite.Move(MoveCount: Integer);
<b>var
  </b>I: Integer;
<b>begin
  if </b>FMoved <b>then
  begin
    </b>DoMove(MoveCount);
    <b>for </b>I := <font color="#000080">0 </font><b>to </b>Count - <font color="#000080">1 </font><b>do
    begin
      </b>Items[I].Move(MoveCount);
    <b>end</b>;
  <b>end</b>;
<b>end</b>;

<b>procedure </b>TSprite.Draw;
<b>var
  </b>i: Integer;
<b>begin
  if </b>FVisible <b>then
  begin
    if </b>FEngine &lt;&gt; <b>nil then
    begin
      if </b>OverlapRect(FEngine.FSurfaceRect, BoundsRect) <b>then
      begin
        </b>DoDraw;
        Inc(FEngine.FDrawCount);
      <b>end</b>;
    <b>end</b>;

    <b>if </b>FDrawList &lt;&gt; <b>nil then
    begin
      for </b>i := <font color="#000080">0 </font><b>to </b>FDrawList.Count - <font color="#000080">1 </font><b>do
        </b>TSprite(FDrawList[i]).Draw;
    <b>end</b>;
  <b>end</b>;
<b>end</b>;

<b>function </b>TSprite.GetSpriteAt(X, Y: Integer): TSprite;

  <b>procedure </b>Collision_GetSpriteAt(X, Y: Double; Sprite: TSprite);
  <b>var
    </b>i: Integer;
    X2, Y2: Double;
  <b>begin
    if </b>Sprite.Visible <b>and </b>PointInRect(Point(Round(X), Round(Y)), Bounds(Round(Sprite.X), Round(Sprite.Y), Sprite.Width, Sprite.Width)) <b>then
    begin
      if </b>(Result = <b>nil</b>) <b>or </b>(Sprite.Z &gt; Result.Z) <b>then
        </b>Result := Sprite;
    <b>end</b>;

    X2 := X - Sprite.X;
    Y2 := Y - Sprite.Y;
    <b>for </b>i := <font color="#000080">0 </font><b>to </b>Sprite.Count - <font color="#000080">1 </font><b>do
      </b>Collision_GetSpriteAt(X2, Y2, Sprite.Items[i]);
  <b>end</b>;

<b>var
  </b>i: Integer;
  X2, Y2: Double;
<b>begin
  </b>Result := <b>nil</b>;

  X2 := X - Self.X;
  Y2 := Y - Self.Y;
  <b>for </b>i := <font color="#000080">0 </font><b>to </b>Count - <font color="#000080">1 </font><b>do
    </b>Collision_GetSpriteAt(X2, Y2, Items[i]);
<b>end</b>;

<b>function </b>TSprite.GetBoundsRect: TRect;
<b>begin
  </b>Result := Bounds(Trunc(WorldX), Trunc(WorldY), Width, Height);
<b>end</b>;

<b>function </b>TSprite.GetClientRect: TRect;
<b>begin
  </b>Result := Bounds(<font color="#000080">0</font>, <font color="#000080">0</font>, Width, Height);
<b>end</b>;

<b>function </b>TSprite.GetCount: Integer;
<b>begin
  if </b>FList &lt;&gt; <b>nil then
    </b>Result := FList.Count
  <b>else
    </b>Result := <font color="#000080">0</font>;
<b>end</b>;

<b>function </b>TSprite.GetItem(Index: Integer): TSprite;
<b>begin
  if </b>FList &lt;&gt; <b>nil then
    </b>Result := FList[Index]
  <b>else
    raise </b>EError.Create(<font color="#000080">'function TSprite.GetItem(Index: Integer): TSprite'</font>);
<b>end</b>;

<b>function </b>TSprite.GetWorldX: Single;
<b>begin
  if </b>Parent &lt;&gt; <b>nil then
    </b>Result := Parent.WorldX + FX
  <b>else
    </b>Result := FX;
<b>end</b>;

<b>function </b>TSprite.GetWorldY: Single;
<b>begin
  if </b>Parent &lt;&gt; <b>nil then
    </b>Result := Parent.WorldY + FY
  <b>else
    </b>Result := FY;
<b>end</b>;

<b>procedure </b>TSprite.SetZ(Value: Integer);
<b>begin
  if </b>FZ &lt;&gt; Value <b>then
  begin
    </b>FZ := Value;
    <b>if </b>Parent &lt;&gt; <b>nil then
    begin
      </b>Parent.FDrawList.Remove(Self);
      Parent.AddDrawList(Self);
    <b>end</b>;
  <b>end</b>;
<b>end</b>;

  <font color="#000080"><i>(* TSpriteEngine *)

</i></font><b>constructor </b>TSpriteEngine.Create(AParent: TSprite);
<b>begin
  inherited </b>Create(AParent);
  FDeadList := TList.Create;
<b>end</b>;

<b>destructor </b>TSpriteEngine.Destroy;
<b>begin
  </b>FDeadList.Free;
  <b>inherited </b>Destroy;
<b>end</b>;

<b>procedure </b>TSpriteEngine.Dead;
<b>begin
  while </b>FDeadList.Count &gt; <font color="#000080">0 </font><b>do
    </b>TSprite(FDeadList[FDeadList.Count - <font color="#000080">1</font>]).Free;
<b>end</b>;

<b>procedure </b>TSpriteEngine.Draw;
<b>begin
  </b>FDrawCount := <font color="#000080">0</font>;
  <b>inherited </b>Draw;
<b>end</b>;

<b>procedure </b>TSpriteEngine.SetSurface;
<b>begin
  </b>FSurfaceRect := Value;
  Width := FSurfaceRect.Right - FSurfaceRect.Left;
  Height := FSurfaceRect.Bottom - FSurfaceRect.Top;
<b>end</b>;

<font color="#000080"><i>{  TBackgroundSprite  }

</i></font><b>constructor </b>TBackgroundSprite.Create(AParent: TSprite);
<b>begin
  inherited </b>Create(AParent);
  Collisioned := False;
<b>end</b>;

<b>destructor </b>TBackgroundSprite.Destroy;
<b>begin
  </b>SetMapSize(<font color="#000080">0</font>, <font color="#000080">0</font>);
  <b>inherited </b>Destroy;
<b>end</b>;

<b>procedure </b>TBackgroundSprite.DoDraw;
<b>var
  </b>_x, _y, cx, cy, cx2, cy2, c, ChipWidth, ChipHeight: Integer;
  StartX, StartY, EndX, EndY, StartX_, StartY_, OfsX, OfsY, dWidth, dHeight: Integer;
  r: TRect;
<b>begin
  if </b>Image = <b>nil then </b>Exit;

  <b>if </b>(FMapWidth &lt;= <font color="#000080">0</font>) <b>or </b>(FMapHeight &lt;= <font color="#000080">0</font>) <b>then </b>Exit;

  r := Rect(<font color="#000080">0</font>, <font color="#000080">0</font>, Image.Width, Image.Height);
  ChipWidth := r.Right - r.Left;
  ChipHeight := r.Bottom - r.Top;

  dWidth := (FEngine.SurfaceRect.Right + ChipWidth) <b>div </b>ChipWidth + <font color="#000080">1</font>;
  dHeight := (FEngine.SurfaceRect.Bottom + ChipHeight) <b>div </b>ChipHeight + <font color="#000080">1</font>;

  _x := Trunc(WorldX);
  _y := Trunc(WorldY);

  OfsX := _x <b>mod </b>ChipWidth;
  OfsY := _y <b>mod </b>ChipHeight;

  StartX := _x <b>div </b>ChipWidth;
  StartX_ := <font color="#000080">0</font>;

  <b>if </b>StartX &lt; <font color="#000080">0 </font><b>then
  begin
    </b>StartX_ := -StartX;
    StartX := <font color="#000080">0</font>;
  <b>end</b>;

  StartY := _y <b>div </b>ChipHeight;
  StartY_ := <font color="#000080">0</font>;

  <b>if </b>StartY &lt; <font color="#000080">0 </font><b>then
  begin
    </b>StartY_ := -StartY;
    StartY := <font color="#000080">0</font>;
  <b>end</b>;

  EndX := Min(StartX + FMapWidth - StartX_, dWidth);
  EndY := Min(StartY + FMapHeight - StartY_, dHeight);

  <b>if </b>FTile <b>then
  begin
    for </b>cy := -<font color="#000080">1 </font><b>to </b>dHeight <b>do
    begin
      </b>cy2 := Mod2((cy - StartY + StartY_), FMapHeight);
      <b>for </b>cx := -<font color="#000080">1 </font><b>to </b>dWidth <b>do
      begin
        </b>cx2 := Mod2((cx - StartX + StartX_), FMapWidth);
        c := Chips[cx2, cy2];
        <b>if </b>c &gt;= <font color="#000080">0 </font><b>then
          </b>Canvas.DrawAlpha(cx * ChipWidth + OfsX, cy * ChipHeight + OfsY, Image, c, <font color="#000080">255</font>);
      <b>end</b>;
    <b>end</b>;
  <b>end else
  begin
    for </b>cy := StartY <b>to </b>EndY - <font color="#000080">1 </font><b>do
      for </b>cx := StartX <b>to </b>EndX - <font color="#000080">1 </font><b>do
      begin
        </b>c := Chips[cx - StartX + StartX_, cy - StartY + StartY_];
        <b>if </b>c &gt;= <font color="#000080">0 </font><b>then
          </b>Canvas.DrawAlpha(cx * ChipWidth + OfsX, cy * ChipHeight + OfsY, Image, c, <font color="#000080">255</font>);
      <b>end</b>;
  <b>end</b>;
<b>end</b>;

<b>function </b>TBackgroundSprite.TestCollision(Sprite: TSprite): Boolean;
<b>var
  </b>b, b1, b2: TRect;
  cx, cy, ChipWidth, ChipHeight: Integer;
  r, k: TRect;
<b>begin
  </b>Result := True;
  <b>if </b>Image = <b>nil then </b>Exit;
  <b>if </b>(FMapWidth &lt;= <font color="#000080">0</font>) <b>or </b>(FMapHeight &lt;= <font color="#000080">0</font>) <b>then </b>Exit;

  r := Rect(<font color="#000080">0</font>, <font color="#000080">0</font>, Image.Width, Image.Height);
  ChipWidth := r.Right - r.Left;
  ChipHeight := r.Bottom - r.Top;

  b1 := Sprite.BoundsRect;
  b2 := BoundsRect;

  IntersectRect(b, b1, b2);

  OffsetRect(b, -Trunc(WorldX), -Trunc(WorldY));
  OffsetRect(b1, -Trunc(WorldX), -Trunc(WorldY));

  <b>for </b>cy := (b.Top - ChipHeight + <font color="#000080">1</font>) <b>div </b>ChipHeight <b>to </b>b.Bottom <b>div </b>ChipHeight <b>do
    for </b>cx := (b.Left - ChipWidth + <font color="#000080">1</font>) <b>div </b>ChipWidth <b>to </b>b.Right <b>div </b>ChipWidth <b>do
      if </b>CollisionMap[Mod2(cx, MapWidth), Mod2(cy, MapHeight)] <b>then
      begin
        if </b>OverlapRect(Bounds(cx * ChipWidth, cy * ChipHeight, ChipWidth, ChipHeight), b1) <b>then </b>Exit;
      <b>end</b>;

  Result := False;
<b>end</b>;

<b>function </b>TBackgroundSprite.GetChip(X, Y: Integer): Integer;
<b>begin
  if </b>(X &gt;= <font color="#000080">0</font>) <b>and </b>(X &lt; FMapWidth) <b>and </b>(Y &gt;= <font color="#000080">0</font>) <b>and </b>(Y &lt; FMapHeight) <b>then
    </b>Result := PInteger(Integer(FMap) + (Y * FMapWidth + X) * SizeOf(Integer))^
  <b>else
    </b>Result := -<font color="#000080">1</font>;
<b>end</b>;

<b>type
  </b>PBoolean = ^Boolean;

<b>function </b>TBackgroundSprite.GetCollisionMapItem(X, Y: Integer): Boolean;
<b>begin
  if </b>(X &gt;= <font color="#000080">0</font>) <b>and </b>(X &lt; FMapWidth) <b>and </b>(Y &gt;= <font color="#000080">0</font>) <b>and </b>(Y &lt; FMapHeight) <b>then
    </b>Result := PBoolean(Integer(FCollisionMap) + (Y * FMapWidth + X) * SizeOf(Boolean))^
  <b>else
    </b>Result := False;
<b>end</b>;

<b>function </b>TBackgroundSprite.GetBoundsRect: TRect;
<b>begin
  if </b>FTile <b>then
    </b>Result := FEngine.SurfaceRect
  <b>else
  begin
    if </b>Image &lt;&gt; <b>nil then
      </b>Result := Bounds(Trunc(WorldX), Trunc(WorldY),
        Image.Width * FMapWidth, Image.Height * FMapHeight)
    <b>else
      </b>Result := Rect(<font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>);
  <b>end</b>;
<b>end</b>;

<b>procedure </b>TBackgroundSprite.SetChip(X, Y: Integer; Value: Integer);
<b>begin
  if </b>(X &gt;= <font color="#000080">0</font>) <b>and </b>(X &lt; FMapWidth) <b>and </b>(Y &gt;= <font color="#000080">0</font>) <b>and </b>(Y &lt; FMapHeight) <b>then
    </b>PInteger(Integer(FMap) + (Y * FMapWidth + X) * SizeOf(Integer))^ := Value;
<b>end</b>;

<b>procedure </b>TBackgroundSprite.SetCollisionMapItem(X, Y: Integer; Value: Boolean);
<b>begin
  if </b>(X &gt;= <font color="#000080">0</font>) <b>and </b>(X &lt; FMapWidth) <b>and </b>(Y &gt;= <font color="#000080">0</font>) <b>and </b>(Y &lt; FMapHeight) <b>then
    </b>PBoolean(Integer(FCollisionMap) + (Y * FMapWidth + X) * SizeOf(Boolean))^ := Value;
<b>end</b>;

<b>procedure </b>TBackgroundSprite.SetMapHeight(Value: Integer);
<b>begin
  </b>SetMapSize(FMapWidth, Value);
<b>end</b>;

<b>procedure </b>TBackgroundSprite.SetMapWidth(Value: Integer);
<b>begin
  </b>SetMapSize(Value, FMapHeight);
<b>end</b>;

<b>procedure </b>TBackgroundSprite.SetMapSize(AMapWidth, AMapHeight: Integer);
<b>begin
  if </b>(FMapWidth &lt;&gt; AMapWidth) <b>or </b>(FMapHeight &lt;&gt; AMapHeight) <b>then
  begin
    if </b>(AMapWidth &lt;= <font color="#000080">0</font>) <b>or </b>(AMapHeight &lt;= <font color="#000080">0</font>) <b>then
    begin
      </b>AMapWidth := <font color="#000080">0</font>;
      AMapHeight := <font color="#000080">0</font>;
    <b>end</b>;
    FMapWidth := AMapWidth;
    FMapHeight := AMapHeight;
    ReAllocMem(FMap, FMapWidth * FMapHeight * SizeOf(Integer));
    FillChar(FMap^, FMapWidth * FMapHeight * SizeOf(Integer), <font color="#000080">0</font>);

    ReAllocMem(FCollisionMap, FMapWidth * FMapHeight * SizeOf(Boolean));
    FillChar(FCollisionMap^, FMapWidth * FMapHeight * SizeOf(Boolean), <font color="#000080">1</font>);
  <b>end</b>;
<b>end</b>;

<font color="#000080"><i>{  TImageSprite  }

</i></font><b>constructor </b>TImageSprite.Create(AParent: TSprite);
<b>begin
  inherited </b>Create(AParent);
  FTransparent := True;
  FAlpha := <font color="#000080">255</font>;
  FAngle := <font color="#000080">0.0</font>;
  FScale := D3DXVector2(<font color="#000080">1.0</font>, <font color="#000080">1.0</font>);
  FShadow := False;
  FShadowAlpha := <font color="#000080">70</font>;
  FShadowX := <font color="#000080">30</font>;
  FShadowY := <font color="#000080">40</font>;
  FShadowScale := D3DXVector2(<font color="#000080">1.0</font>, <font color="#000080">1.0</font>);
<b>end</b>;

<b>function </b>TImageSprite.GetBoundsRect: TRect;
<b>var
  </b>dx, dy: Integer;
<b>begin
  </b>dx := Trunc(WorldX);
  dy := Trunc(WorldY);
  <b>if </b>FTile <b>then
  begin
    </b>dx := Mod2(dx, FEngine.SurfaceRect.Right + Width);
    dy := Mod2(dy, FEngine.SurfaceRect.Bottom + Height);

    <b>if </b>dx &gt; FEngine.SurfaceRect.Right <b>then
      </b>dx := (dx - FEngine.SurfaceRect.Right) - Width;

    <b>if </b>dy &gt; FEngine.SurfaceRect.Bottom <b>then
      </b>dy := (dy - FEngine.SurfaceRect.Bottom) - Height;
  <b>end</b>;

  Result := Bounds(dx, dy, Width, Height);
<b>end</b>;

<b>procedure </b>TImageSprite.DoMove(MoveCount: Integer);
<b>begin
  if </b>FAnimReverse <b>then
    </b>FAnimPos := FAnimPos - FAnimSpeed * MoveCount
  <b>else
    </b>FAnimPos := FAnimPos + FAnimSpeed * MoveCount;

  <b>if </b>FAnimLooped <b>then
  begin
    if </b>FAnimCount &gt; <font color="#000080">0 </font><b>then
      </b>FAnimPos := Mod2f(FAnimPos, FAnimCount)
    <b>else
      </b>FAnimPos := <font color="#000080">0</font>;
  <b>end else
  begin
    if </b>FAnimPos &gt;= FAnimCount <b>then
    begin
      </b>FAnimPos := FAnimCount - <font color="#000080">1</font>;
      FAnimSpeed := <font color="#000080">0</font>;
    <b>end</b>;
    <b>if </b>FAnimPos &lt; <font color="#000080">0 </font><b>then
    begin
      </b>FAnimPos := <font color="#000080">0</font>;
      FAnimSpeed := <font color="#000080">0</font>;
    <b>end</b>;
  <b>end</b>;
<b>end</b>;

<b>function </b>TImageSprite.GetDrawImageIndex: Integer;
<b>begin
  </b>Result := FAnimStart + Trunc(FAnimPos);
<b>end</b>;

<b>function </b>TImageSprite.GetDrawRect: TRect;
<b>begin
  </b>Result := BoundsRect;
  OffsetRect(Result, (Width - Image.Width) <b>div </b><font color="#000080">2</font>, (Height - Image.Height) <b>div </b><font color="#000080">2</font>);
<b>end</b>;

<b>procedure </b>TImageSprite.DoDraw;
<b>var
  </b>ImageIndex: Integer;
  r: TRect;
  Pos: TD3DXVector2;
<b>begin
  </b>ImageIndex := GetDrawImageIndex;

  r := GetDrawRect;

  <b>if </b>FShadow <b>then
  begin
    </b>Pos := D3DXVector2(r.Left + FShadowX, r.Top + FShadowY);
    Canvas.Sprite.Draw(Image.PatternTextures[ImageIndex].Image, <b>nil</b>, @FShadowScale, @Center, D3DXToRadian(Angle), @Pos, (ShadowAlpha <b>shl </b><font color="#000080">24</font>) + clBlack)
  <b>end</b>;

  Pos := D3DXVector2(r.Left, r.Top);
  Canvas.Sprite.Draw(Image.PatternTextures[ImageIndex].Image, <b>nil</b>, @FScale, @Center, D3DXToRadian(Angle), @Pos, (Alpha <b>shl </b><font color="#000080">24</font>) + clWhite);
<b>end</b>;

<b>function </b>ImageCollisionTest(suf1, suf2: IDirect3DTexture8; <b>const </b>rect1, rect2: TRect;
  x1, y1, x2, y2: Integer; DoPixelCheck: Boolean): Boolean;

  <b>function </b>ClipRect(<b>var </b>DestRect: TRect; <b>const </b>DestRect2: TRect): Boolean;
  <b>begin
    with </b>DestRect <b>do
    begin
      </b>Left := Max(Left, DestRect2.Left);
      Right := Min(Right, DestRect2.Right);
      Top := Max(Top, DestRect2.Top);
      Bottom := Min(Bottom, DestRect2.Bottom);

      Result := (Left &lt; Right) <b>and </b>(Top &lt; Bottom);
    <b>end</b>;
  <b>end</b>;

<b>type
  </b>PRGB = ^TRGB;
  TRGB = <b>packed record
    </b>R, G, B: Byte;
  <b>end</b>;
<b>var
  </b>ddsd1, ddsd2: TD3DSurfaceDesc;
  r1, r2: TRect;
  tc1, tc2: DWORD;
  x, y, w, h: Integer;
  P1, P2: Pointer;
  LockedRect1: D3DLOCKED_RECT;
  LockedRect2: D3DLOCKED_RECT;
<b>begin
  </b>Result := True;
  r1 := rect1;
  <b>with </b>rect2 <b>do </b>r2 := Bounds(x2 - x1, y2 - y1, Right - Left, Bottom - Top);

  Result := OverlapRect(r1, r2);

 <font color="#000080"><i>{ if (suf1 = nil) or (suf2 = nil) then Exit;

  if DoPixelCheck and Result then
  begin
    {  Get Overlapping rectangle  }
  {  with r1 do r1 := Bounds(Max(x2 - x1, 0), Max(y2 - y1, 0), Right - Left, Bottom - Top);
    with r2 do r2 := Bounds(Max(x1 - x2, 0), Max(y1 - y2, 0), Right - Left, Bottom - Top);

    ClipRect(r1, rect1);
    ClipRect(r2, rect2);

    w := Min(r1.Right - r1.Left, r2.Right - r2.Left);
    h := Min(r1.Bottom - r1.Top, r2.Bottom - r2.Top);

    ClipRect(r1, bounds(r1.Left, r1.Top, w, h));
    ClipRect(r2, bounds(r2.Left, r2.Top, w, h));

    {  Pixel check !!!  }
  {  ddsd1.Size := SizeOf(ddsd1);
    if Succeeded(suf1.LockRect(LockedRect1, @r1, 0)) then
    begin
      try
        ddsd2.Size := SizeOf(ddsd2);
        if (suf1 = suf2) or Succeeded(suf2.LockRect(LockedRect2, @r2, 0)) then
        begin
          try
            if suf1 = suf2 then ddsd2 := ddsd1;
            if ddsd1.Format &lt;&gt; ddsd2.Format then Exit;

            {  Get transparent color  }
//            tc1 := ddsd1.ddckCKSrcBlt.dwColorSpaceLowValue;
//            tc2 := ddsd2.ddckCKSrcBlt.dwColorSpaceLowValue;

      {      tc1 := clFuchsia;
            tc2 := clFuchsia;

            case ddsd1.Format of
              D3DFMT_R3G3B2: begin
                  for y := 0 to h - 1 do
                  begin
                    P1 := Pointer(Integer(ddsd1.lpSurface) + y * ddsd1.lPitch);
                    P2 := Pointer(Integer(ddsd2.lpSurface) + y * ddsd2.lPitch);
                    for x := 0 to w - 1 do
                    begin
                      if (PByte(P1)^ &lt;&gt; tc1) and (PByte(P2)^ &lt;&gt; tc2) then Exit;
                      Inc(PByte(P1));
                      Inc(PByte(P2));
                    end;
                  end;
                end;
              D3DFMT_R5G6B5: begin
                  for y := 0 to h - 1 do
                  begin
                    P1 := Pointer(Integer(ddsd1.lpSurface) + y * ddsd1.lPitch);
                    P2 := Pointer(Integer(ddsd2.lpSurface) + y * ddsd2.lPitch);
                    for x := 0 to w - 1 do
                    begin
                      if (PWord(P1)^ &lt;&gt; tc1) and (PWord(P2)^ &lt;&gt; tc2) then Exit;
                      Inc(PWord(P1));
                      Inc(PWord(P2));
                    end;
                  end;
                end;
              D3DFMT_X8R8G8B8: begin
                  for y := 0 to h - 1 do
                  begin
                    P1 := Pointer(Integer(ddsd1.lpSurface) + y * ddsd1.lPitch);
                    P2 := Pointer(Integer(ddsd2.lpSurface) + y * ddsd2.lPitch);
                    for x := 0 to w - 1 do
                    begin
                      if ((PRGB(P1)^.R shl 16) or (PRGB(P1)^.G shl 8) or PRGB(P1)^.B &lt;&gt; tc1) and
                        ((PRGB(P2)^.R shl 16) or (PRGB(P2)^.G shl 8) or PRGB(P2)^.B &lt;&gt; tc2) then Exit;
                      Inc(PRGB(P1));
                      Inc(PRGB(P2));
                    end;
                  end;
                end;
              D3DFMT_A8R8G8B8: begin
                  for y := 0 to h - 1 do
                  begin
                    P1 := Pointer(Integer(ddsd1.lpSurface) + y * ddsd1.lPitch);
                    P2 := Pointer(Integer(ddsd2.lpSurface) + y * ddsd2.lPitch);
                    for x := 0 to w - 1 do
                    begin
                      if (PDWORD(P1)^ and $FFFFFF &lt;&gt; tc1) and (PDWORD(P2)^ and $FFFFFF &lt;&gt; tc2) then Exit;
                      Inc(PDWORD(P1));
                      Inc(PDWORD(P2));
                    end;
                  end;
                end;
            end;
          finally
            if suf1 &lt;&gt; suf2 then suf2.UnLock;
          end;
        end;
      finally
        suf1.UnLock;
      end;
    end;

    Result := False;
  end;   }
</i></font><b>end</b>;

<b>function </b>TImageSprite.TestCollision(Sprite: TSprite): Boolean;
<b>var
  </b>img1, img2: Integer;
  b1, b2: TRect;
<b>begin
  if </b>(Sprite <b>is </b>TImageSprite) <b>and </b>FPixelCheck <b>then
  begin
    </b>b1 := GetDrawRect;
    b2 := TImageSprite(Sprite).GetDrawRect;

    img1 := GetDrawImageIndex;
    img2 := TImageSprite(Sprite).GetDrawImageIndex;

    Result := ImageCollisionTest(Image.PatternTextures[img1].Image, TImageSprite(Sprite).Image.PatternTextures[img2].Image,
      Rect(<font color="#000080">0</font>, <font color="#000080">0</font>, Image.Width, Image.Height), Rect(<font color="#000080">0</font>, <font color="#000080">0</font>, TImageSprite(Sprite).Image.Width, TImageSprite(Sprite).Image.Height),
      b1.Left, b1.Top, b2.Left, b2.Top, True);
  <b>end else
    </b>Result := <b>inherited </b>TestCollision(Sprite);
<b>end</b>;

<b>initialization
  </b>InitCosinTable;
  
<b>end</b>.
</font>
</code></pre>
</body>
</html>
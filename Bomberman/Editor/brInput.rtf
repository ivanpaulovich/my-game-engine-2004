{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue128;\red0\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title brInput.rtf}}

\deflang1033\pard\plain\f0\fs20 \cf0\i (*******************************************************)
\par (*                                                     *)
\par (*       Engine Paulovich DirectX                      *)
\par (*       Win32-DirectX API Unit                        *)
\par (*                                                     *)
\par (*       Copyright (c) 2003-2004, Ivan Paulovich       *)
\par (*                                                     *)
\par (*       iskatrek@hotmail.com  uin#89160524            *)
\par (*                                                     *)
\par (*       Unit: brInput                                 *)
\par (*                                                     *)
\par (*******************************************************)
\par 
\par \i0\cf1\b unit \b0 brInput;
\par 
\par \b interface
\par 
\par uses
\par   \b0 Windows, DirectInput8, SysUtils;
\par 
\par \b type
\par 
\par   \b0 TTimedInput = \b record
\par     \b0 Time: dWord;
\par     Used: boolean;
\par   \b end\b0 ;
\par 
\par   TInput = \b class
\par   private
\par     \b0 FHandle: HWnd;
\par     DI8: IDirectInput8;
\par     DIK8: IDirectInputDevice8;
\par     DIM8: IDirectInputDevice8;
\par     DIJ8: IDirectInputDevice8;
\par     DIMEvent: THandle;
\par     DIMou0Clicked: Boolean;
\par     DIMou1Clicked: Boolean;
\par     DIJ8Caps: TDIDevCaps;
\par     \b function \b0 EnumJoysticksCallback(Device: PDIDeviceInstance; Ref: Pointer): Integer;
\par     \b function \b0 EnumAxesCallback(\b var \b0 Device: TDIDeviceObjectInstance; Ref: Pointer): Integer;
\par   \b public
\par     constructor \b0 Create(Handle: HWnd; Keyboard, Mouse, Joystick: Boolean);
\par     \b function \b0 Run: Integer;
\par     \b procedure \b0 Clear;
\par     \b function \b0 InitializeMouse: Boolean;
\par     \b function \b0 InitializeJoystick: Boolean;
\par     \b function \b0 InitializeKeyboard: Boolean;
\par     \b function \b0 MouseAcquire(Acquire: Boolean): Boolean;
\par     \b function \b0 MouseState(\b var \b0 X, Y: LongInt; \b var \b0 Up0, Down0, DblClk0,
\par       Up1, Down1, DblClk1: Longint): Boolean;
\par     \b function \b0 JoystickState(\b var \b0 Data: TDIJoyState2): Boolean;
\par     \b function \b0 KeyboardAcquire(Acquire: Boolean): Boolean;
\par     \b function \b0 KeyboardState: Boolean;
\par     \b function \b0 KeyDown(Key: Byte): Boolean;
\par     \b property \b0 Handle: HWnd \b read \b0 FHandle;
\par   \b end\b0 ;
\par 
\par \b var
\par   \b0 Input: TInput = \b nil\b0 ;
\par 
\par \b procedure \b0 TimedInputReset(\b var \b0 Ti: TTimedInput);
\par \b function \b0 TimedInputRefresh(\b var \b0 Ti: TTimedInput; _Time, TimeOut: DWord;
\par   Condition: Boolean): Longint;
\par 
\par \b implementation
\par 
\par uses
\par   \b0 brForms;
\par 
\par \b const
\par   \b0 DIMBufSize = \cf0 16\cf1 ;
\par   DIMTimeOut = \cf0 250\cf1 ;
\par 
\par   DIJoyRange = \cf0 32768\cf1 ;
\par 
\par \b var
\par   \b0 DIMButSwapped: Boolean = False;
\par   DIM0Released: DWord = \cf0 0\cf1 ;
\par   DIM1Released: DWord = \cf0 0\cf1 ;
\par 
\par   DIKeyBuffer: \b array\b0 [\cf0 0\cf1 ..\cf0 255\cf1 ] \b of \b0 Byte;
\par 
\par \b procedure \b0 TimedInputReset(\b var \b0 Ti: TTimedInput);
\par \b begin
\par   \b0 Ti.Time := \cf0 0\cf1 ;
\par   Ti.Used := False;
\par \b end\b0 ;
\par 
\par \b function \b0 TimedInputRefresh(\b var \b0 Ti: TTimedInput; _Time, TimeOut: DWord;
\par   Condition: Boolean): LongInt;
\par 
\par \b begin
\par   \b0 Result := \cf0 0\cf1 ;
\par   \b if \b0 (Ti.Time = \cf0 0\cf1 ) \b and \b0 (Condition) \b then
\par   begin
\par     \b0 Ti.Time := _Time;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 Ti.Time <> \cf0 0 \cf1\b then
\par     if \b0 Condition \b then
\par     begin
\par       if \b0 _Time - Ti.Time >= Timeout \b then
\par       begin
\par         \b0 Ti.Used := true;
\par         \b while \b0 _Time - Ti.Time >= Timeout \b do
\par         begin
\par           \b0 Inc(Result);
\par           Inc(Ti.Time, Timeout)
\par         \b end\b0 ;
\par       \b end\b0 ;
\par     \b end
\par     else
\par     begin
\par       if not \b0 Ti.Used \b then
\par         \b0 Inc(Result);
\par       Ti.Used := false;
\par       Ti.Time := \cf0 0\cf1 ;
\par     \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b function \b0 GlobalEnumJoysticksCallback(Device: PDIDeviceInstance; Ref: Pointer): Integer; \b stdcall\b0 ;
\par \b begin
\par   \b0 Input.EnumJoysticksCallback(Device, Ref);
\par \b end\b0 ;
\par 
\par \b function \b0 GlobalEnumAxesCallback(\b var \b0 Device: TDIDeviceObjectInstance; Ref: pointer): Integer; \b stdcall\b0 ;
\par \b begin
\par   \b0 Input.EnumAxesCallback(Device, Ref);
\par \b end\b0 ;
\par 
\par \b constructor \b0 TInput.Create;
\par \b begin
\par   if \b0 Assigned(Input) \b then
\par     raise \b0 ELogError.Create(Format(ERROR_EXISTS, [\cf0 'TInput'\cf1 ]))
\par   \b else
\par     \b0 SaveLog(Format(EVENT_CREATE, [\cf0 'TInput'\cf1 ]));
\par   DI8 := \b nil\b0 ;
\par   DIK8 := \b nil\b0 ;
\par   DIM8 := \b nil\b0 ;
\par   DIJ8 := \b nil\b0 ;
\par   FHandle := Handle;
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.Run: Integer;
\par \b begin
\par   \b0 Clear;
\par 
\par   SaveLog(Format(EVENT_TALK, [\cf0 'TInput.Run'\cf1 ]));
\par 
\par   \b if \b0 Failed(DirectInput8Create(hInstance, DIRECTINPUT_VERSION, IID_IDirectInput8,
\par     DI8, \b nil\b0 )) \b then
\par     \b0 Result := E_FAIL
\par   \b else
\par     \b0 Result := S_OK;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TInput.Clear;
\par \b begin
\par   if \b0 Assigned(DI8) \b then
\par   begin
\par     if \b0 Assigned(DIK8) \b then
\par     begin
\par       \b0 DIK8.Unacquire;
\par       DIK8 := \b nil\b0 ;
\par     \b end\b0 ;
\par     \b if \b0 Assigned(DIM8) \b then
\par     begin
\par       \b0 DIM8.Unacquire;
\par       DIM8 := \b nil\b0 ;
\par     \b end\b0 ;
\par     \b if \b0 Assigned(DIJ8) \b then
\par     begin
\par       \b0 DIJ8.Unacquire;
\par       DIJ8 := \b nil\b0 ;
\par     \b end\b0 ;
\par     DI8 := \b nil\b0 ;
\par   \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.InitializeMouse: Boolean;
\par \b var
\par   \b0 Prop: TDIPropDWord;
\par \b begin
\par   \b0 Result := false;
\par 
\par   DIMButSwapped := GetSystemMetrics(SM_SWAPBUTTON) <> \cf0 0\cf1 ;
\par 
\par   \b if \b0 Failed(DI8.CreateDevice(GUID_SysMouse, DIM8, \b nil\b0 )) \b then
\par     \b0 Exit;
\par 
\par   \b if \b0 Failed(DIM8.SetDataFormat(@c_dfDIMouse)) \b then
\par     \b0 Exit;
\par 
\par   \b if \b0 Failed(DIM8.SetCooperativeLevel(Handle, DISCL_FOREGROUND \b or \b0 DISCL_EXCLUSIVE)) \b then
\par     \b0 Exit;
\par 
\par   DIMEvent := CreateEvent(\b nil\b0 , False, False, \b nil\b0 );
\par   \b if \b0 DIMEvent = \cf0 0 \cf1\b then
\par     \b0 Exit;
\par 
\par   \b if \b0 Failed(DIM8.SetEventNotification(DIMEvent)) \b then
\par     \b0 Exit;
\par 
\par   \b with \b0 Prop \b do begin
\par     \b0 diph.dwSize := SizeOf(TDIPropDWord);
\par     diph.dwHeaderSize := SizeOf(TDIPropHeader);
\par     diph.dwObj := \cf0 0\cf1 ;
\par     diph.dwHow := DIPH_DEVICE;
\par     dwData := DIMBufSize;
\par   \b end\b0 ;
\par 
\par   \b if \b0 Failed(DIM8.SetProperty(DIPROP_BUFFERSIZE, Prop.diph)) \b then
\par     \b0 Exit;
\par 
\par   Result := True;
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.MouseAcquire(Acquire: Boolean): Boolean;
\par \b begin
\par   if not \b0 Acquire \b then
\par     \b0 Result := \b not \b0 Failed(DIM8.Unacquire)
\par   \b else
\par     \b0 Result := \b not \b0 Failed(DIM8.Acquire);
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.MouseState(\b var \b0 X, Y: LongInt; \b var \b0 Up0, Down0, DblClk0,
\par   Up1, Down1, DblClk1: Longint): Boolean;
\par \b var
\par   \b0 Hr: HRESULT;
\par   Objdata: TDIDeviceObjectData;
\par   Zero, One: Boolean;
\par   _Time: DWord;
\par   Elements: DWord;
\par \b begin
\par   \b0 Result := false;
\par 
\par   X := \cf0 0\cf1 ;
\par   Y := \cf0 0\cf1 ;
\par   Up0 := \cf0 0\cf1 ;
\par   Down0 := \cf0 0\cf1 ;
\par   DblClk0 := \cf0 0\cf1 ;
\par   Up1 := \cf0 0\cf1 ;
\par   Down1 := \cf0 0\cf1 ;
\par   DblClk1 := \cf0 0\cf1 ;
\par 
\par   \b repeat
\par     \b0 Elements := \cf0 1\cf1 ;
\par     Hr := DIM8.GetDeviceData(SizeOf(TDIDeviceObjectData), @Objdata, Elements, \cf0 0\cf1 );
\par     \b if \b0 Hr = DIERR_INPUTLOST \b then
\par     begin
\par       \b0 Hr := DIM8.Acquire;
\par       \b if not \b0 Failed(hr) \b then
\par         \b0 Hr := DIM8.GetDeviceData(SizeOf(TDIDeviceObjectData), @ObjData, Elements, \cf0 0\cf1 );
\par     \b end\b0 ;
\par 
\par     \b if \b0 (Failed(Hr)) \b then
\par       \b0 Exit;
\par     Result := True;
\par     \b if \b0 (Elements = \cf0 0\cf1 ) \b then
\par       \b0 Exit;
\par 
\par     Zero := False;
\par     One := False;
\par     \b case \b0 ObjData.dwOfs \b of
\par       \b0 DIMOFS_X: X := X + LongInt(ObjData.dwData);
\par       DIMOFS_Y: Y := Y + LongInt(ObjData.dwData);
\par       DIMOFS_BUTTON0: \b if \b0 DIMButSwapped \b then
\par           \b0 One := True
\par         \b else
\par           \b0 Zero := True;
\par       DIMOFS_BUTTON1: \b if \b0 DIMButSwapped \b then
\par           \b0 Zero := True
\par         \b else
\par           \b0 One := True;
\par     \b end\b0 ;
\par 
\par     \b if \b0 Zero \b then
\par     begin
\par       \b0 DIMou0Clicked := (ObjData.dwData \b and \b0\cf0 $80 \cf1 = \cf0 $80\cf1 );
\par       \b if not \b0 DIMou0Clicked \b then
\par       begin
\par         \b0 Inc(Up0);
\par 
\par         _Time := GetTickCount;
\par         \b if \b0 (_Time - DIM0Released < DIMTimeOut) \b then
\par         begin
\par           \b0 DIM0Released := \cf0 0\cf1 ;
\par           Inc(DblClk0);
\par         \b end
\par         else
\par           \b0 DIM0Released := _time;
\par       \b end
\par       else
\par         \b0 Inc(Down0);
\par     \b end\b0 ;
\par 
\par     \b if \b0 One \b then
\par     begin
\par       \b0 DIMou1Clicked := (ObjData.dwData \b and \b0\cf0 $80 \cf1 = \cf0 $80\cf1 );
\par       \b if not \b0 DIMou1Clicked \b then
\par       begin
\par         \b0 Inc(Up1);
\par 
\par         _Time := GetTickCount;
\par         \b if \b0 (_Time - DIM1Released < DIMTimeOut) \b then
\par         begin
\par           \b0 DIM1Released := \cf0 0\cf1 ;
\par           Inc(DblClk1);
\par         \b end
\par         else
\par           \b0 DIM1Released := _Time;
\par       \b end
\par       else
\par         \b0 Inc(Down1);
\par     \b end\b0 ;
\par   \b until \b0 Elements = \cf0 0\cf1 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.EnumJoysticksCallback(Device: PDIDeviceInstance; Ref: Pointer): Integer;
\par \b begin
\par   \b0 Result := DIENUM_CONTINUE;
\par   \b if \b0 Failed(DI8.CreateDevice(Device.guidInstance, DIJ8, \b nil\b0 )) \b then
\par     \b0 Exit;
\par   Result := DIENUM_STOP;
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.EnumAxesCallback(\b var \b0 Device: TDIDeviceObjectInstance; Ref: Pointer): Integer;
\par \b var
\par   \b0 PropRange: TDIPropRange;
\par \b begin
\par   \b0 Result := DIENUM_CONTINUE;
\par 
\par   PropRange.diph.dwSize := Sizeof(TDIPropRange);
\par   PropRange.diph.dwHeaderSize := Sizeof(TDIPropHeader);
\par   PropRange.diph.dwHow := DIPH_BYID;
\par   PropRange.diph.dwObj := Device.dwType;
\par   PropRange.lMin := -DIJoyRange;
\par   PropRange.lMax := DIJoyRange;
\par 
\par   \b if \b0 Failed(DIJ8.SetProperty(DIPROP_RANGE, PropRange.diph)) \b then
\par     \b0 Result := DIENUM_STOP;
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.InitializeJoystick: Boolean;
\par \b begin
\par   \b0 Result := False;
\par 
\par   DI8.EnumDevices(DI8DEVCLASS_GAMECTRL, @GlobalEnumJoysticksCallback, \b nil\b0 , DIEDFL_ATTACHEDONLY);
\par   \b if \b0 DIJ8 = \b nil then
\par     \b0 Exit;
\par 
\par   \b if \b0 Failed(DIJ8.SetDataFormat(@c_dfDIJoystick2)) \b then
\par   begin
\par     \b0 DIJ8 := \b nil\b0 ;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 Failed(DIJ8.SetCooperativeLevel(Handle, DISCL_EXCLUSIVE \b or \b0 DISCL_FOREGROUND)) \b then
\par   begin
\par     \b0 DIJ8 := \b nil\b0 ;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   DIJ8CAPS.dwSize := Sizeof(TDIDevCaps);
\par   \b if \b0 Failed(DIJ8.GetCapabilities(DIJ8CAPS)) \b then
\par   begin
\par     \b0 DIJ8 := \b nil\b0 ;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 Failed(DIJ8.EnumObjects(GlobalEnumAxesCallback, \b nil\b0 , DIDFT_AXIS)) \b then
\par   begin
\par     \b0 DIJ8 := \b nil\b0 ;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   Result := True;
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.JoystickState(\b var \b0 Data: TDIJoyState2): Boolean;
\par \b begin
\par   \b0 Result := False;
\par 
\par   \b if \b0 Failed(DIJ8.Poll) \b then
\par     if \b0 DIJ8.Acquire = DIERR_INPUTLOST \b then
\par       if \b0 Failed(DIJ8.Acquire) \b then
\par         \b0 Exit;
\par 
\par   Result := \b not \b0 Failed(DIJ8.GetDeviceState(Sizeof(TDIJoyState2), @Data));
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.InitializeKeyboard: Boolean;
\par \b begin
\par   \b0 Result := False;
\par 
\par   \b if \b0 Failed(DI8.CreateDevice(GUID_SysKeyboard, DIK8, \b nil\b0 )) \b then
\par     \b0 Exit;
\par 
\par   \b if \b0 Failed(DIK8.SetDataFormat(@c_dfDIKeyboard)) \b then
\par     \b0 Exit;
\par 
\par   \b if \b0 Failed(DIK8.SetCooperativeLevel(Handle, DISCL_FOREGROUND \b or \b0 DISCL_NONEXCLUSIVE)) \b then
\par     \b0 Exit;
\par 
\par   Result := True;
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.KeyboardAcquire(Acquire: Boolean): Boolean;
\par \b var
\par   \b0 Hr: hResult;
\par \b begin
\par   if not \b0 Acquire \b then
\par     \b0 Result := \b not \b0 Failed(DIK8.Unacquire)
\par   \b else
\par     \b0 Result := \b not \b0 Failed(DIK8.Acquire);
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.KeyboardState: Boolean;
\par \b var
\par   \b0 Hr: HRESULT;
\par \b begin
\par   \b0 Hr := DIK8.GetDeviceState(SizeOf(DIKeyBuffer), @DIKeyBuffer);
\par 
\par   \b if \b0 Hr = DIERR_INPUTLOST \b then
\par   begin
\par     \b0 Hr := DIK8.Acquire;
\par     \b if not \b0 Failed(Hr) \b then
\par       \b0 Hr := DIK8.GetDeviceState(SizeOf(DIKeyBuffer), @DIKeyBuffer);
\par   \b end\b0 ;
\par 
\par   Result := \b not \b0 Failed(Hr);
\par \b end\b0 ;
\par 
\par \b function \b0 TInput.KeyDown(Key: Byte): Boolean;
\par \b begin
\par   \b0 Result := (DIKeyBuffer[Key] \b and \b0\cf0 $80 \cf1 = \cf0 $80\cf1 );
\par \b end\b0 ;
\par 
\par \b begin
\par   \b0 ZeroMemory(@DIKeyBuffer, SizeOf(DIKeyBuffer));
\par \b end\b0 .
\par 
\par }
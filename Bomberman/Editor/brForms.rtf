{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue128;\red0\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title brForms.rtf}}

\deflang1033\pard\plain\f0\fs20 \cf0\i (*******************************************************)
\par (*                                                     *)
\par (*       Engine Paulovich DirectX                      *)
\par (*       Win32-DirectX API Unit                        *)
\par (*                                                     *)
\par (*       Copyright (c) 2003-2004, Ivan Paulovich       *)
\par (*                                                     *)
\par (*       iskatrek@hotmail.com  uin#89160524            *)
\par (*                                                     *)
\par (*       Unit: brForms                                 *)
\par (*                                                     *)
\par (*******************************************************)
\par 
\par \i0\cf1\b unit \b0 brForms;
\par 
\par \b interface
\par 
\par uses
\par   \b0 Windows, Messages, Classes, SysUtils, MMSystem, CommDlg, brControls, brGraphics, brInput;
\par 
\par \b const
\par 
\par   \b0\cf0\i (* Arquivos *)
\par 
\par   \i0\cf1 FILE_LOG = \cf0 'log.log'\cf1 ;
\par   FILE_MAP = \cf0 'map.map'\cf1 ;
\par 
\par   \cf0\i (* Filtros *)
\par 
\par   \i0\cf1 FILTER_MAP = \cf0 'Mapas (*.map)'#0'*.map'#0'Todos os arquivos (*.*)'#0'*.*'#0#0\cf1 ;
\par 
\par   \cf0\i (* Mensagens *)
\par 
\par   \i0\cf1 EVENT_START =
\par     \cf0 '-----------------------------------------------------------------' \cf1 + \cf0 #13#10 \cf1 +
\par     \cf0 '------------ Powered by IskaTreK - Copyright(c) 2004 ------------'\cf1 ;
\par   EVENT_TALK = \cf0 'Chamando função: %s'\cf1 ;
\par   EVENT_CREATE = \cf0 'Objeto da classe %s criado.'\cf1 ;
\par   EVENT_APPLICATION = \cf0 '[Aplicação] :: Arquivo: %s'\cf1 ;
\par   EVENT_WINDOW = \cf0 '[Janela] :: Posição: %dx%d. Resolução: %dx%d. Título: %s'\cf1 ;
\par   EVENT_FOUND = \cf0 'Arquivo encontrado: %s'\cf1 ;
\par   EVENT_ERROR = \cf0 'Ocorreu um erro dentro de: %s'\cf1 ;
\par 
\par   \cf0\i (* Erros *)
\par 
\par   \i0\cf1 ERROR_EXISTS = \cf0 'Objeto %s já existente.'\cf1 ;
\par   ERROR_REGISTRY = \cf0 'Impossível registrar janela.'\cf1 ;
\par   ERROR_INSTANCE = \cf0 'Impossível instanciar janela.'\cf1 ;
\par   ERROR_NOTFOUND = \cf0 'Impossível encontrar o arquivo: %s'\cf1 ;
\par   ERROR_MUSICLOADER = \cf0 'Impossível carregar música.'\cf1 ;
\par   ERROR_MUSICPERFORMANCE = \cf0 'Erro na performance.'\cf1 ;
\par   ERROR_INITAUDIO = \cf0 'Impossível inicializar audio.'\cf1 ;
\par   ERROR_PATH = \cf0 'Impossível pegar Path do audio.'\cf1 ;
\par   ERROR_VOLUME = \cf0 'Impossível definir volume'\cf1 ;
\par   ERROR_LOAD = \cf0 'Impossível carregar audio'\cf1 ;
\par   ERROR_DOWNLOAD = \cf0 'Impossível baixar audio'\cf1 ;
\par   ERROR_NOSEGMENT = \cf0 'Não existe o segmento de audio'\cf1 ;
\par   ERROR_PLAYFAIL = \cf0 'Falha ao iniciar audio.'\cf1 ;
\par   ERROR_CREATEDEVICE = \cf0 'Falha ao criar device %s.'\cf1 ;
\par   ERROR_SETDATAFORMAT = \cf0 'Impossível definir formato %s'\cf1 ;
\par   ERROR_SETCOOPERATIVELEVEL = \cf0 'Impossível definir nível cooperativo %%s'\cf1 ;
\par 
\par   \cf0\i (* Cores *)
\par 
\par   \i0\cf1 clRed = \cf0 $FFFF0000\cf1 ;
\par   clGreen = \cf0 $FF00FF00\cf1 ;
\par   clBlue = \cf0 $FF0000FF\cf1 ;
\par   clWhite = \cf0 $FFFFFFFF\cf1 ;
\par   clBlack = \cf0 $FF000000\cf1 ;
\par   clAqua = \cf0 $FF00FFFF\cf1 ;
\par   clFuchsia = \cf0 $FFFF00FF\cf1 ;
\par   clYellow = \cf0 $FFFFFF00\cf1 ;
\par   clMaroon = \cf0 $000080\cf1 ;
\par   clOlive = \cf0 $008080\cf1 ;
\par   clNavy = \cf0 $800000\cf1 ;
\par   clPurple = \cf0 $800080\cf1 ;
\par   clTeal = \cf0 $808000\cf1 ;
\par   clGray = \cf0 $808080\cf1 ;
\par   clSilver = \cf0 $C0C0C0\cf1 ;
\par   clLime = \cf0 $00FF00\cf1 ;
\par   clLtGray = \cf0 $C0C0C0\cf1 ;
\par   clDkGray = \cf0 $808080\cf1 ;
\par 
\par \b const
\par   \b0\cf0\i \{$EXTERNALSYM OPENFILENAME_SIZE_VERSION_400A\}
\par   \i0\cf1 OPENFILENAME_SIZE_VERSION_400A = SizeOf(TOpenFileNameA) -
\par     SizeOf(Pointer) - (\cf0 2 \cf1 * SizeOf(DWord));
\par   \cf0\i \{$EXTERNALSYM OPENFILENAME_SIZE_VERSION_400W\}
\par   \i0\cf1 OPENFILENAME_SIZE_VERSION_400W = SizeOf(TOpenFileNameW) -
\par     Sizeof(Pointer) - (\cf0 2 \cf1 * SizeOf(DWord));
\par   \cf0\i \{$EXTERNALSYM OPENFILENAME_SIZE_VERSION_400\}
\par   \i0\cf1 OPENFILENAME_SIZE_VERSION_400  = OPENFILENAME_SIZE_VERSION_400A;
\par 
\par \b type
\par 
\par   \b0\cf0\i (* Eventos *)
\par 
\par   \i0\cf1 TDoFrameEvent = \b procedure\b0 (Sender: TObject; TimeDelta: Single) \b of object\b0 ;
\par   TExceptionEvent = \b procedure \b0 (Sender: TObject; E: Exception) \b of object\b0 ;
\par 
\par   \cf0\i (* Opções *)
\par 
\par   \i0\cf1 TBorderIcon = (biSystemMenu, biMinimize, biMaximize, biHelp);
\par   TBorderIcons = \b set of \b0 TBorderIcon;
\par   TFormBorderStyle = (bsNone, bsSingle, bsSizeable, bsDialog, bsToolWindow,
\par     bsSizeToolWin);
\par   TPosition = (poLeft, poRight, poTop, poDown, poCenter);
\par 
\par   \cf0\i (* Referências *)
\par 
\par   \i0\cf1 TRefWindow = \b class of \b0 TWindow;
\par 
\par  \cf0\i (* TWindow *)
\par 
\par   \i0\cf1 PWindow = ^TWindow;
\par   TWindow = \b class\b0 (TControl)
\par   \b private
\par     \b0 FHandle: HWnd;
\par     FCaption: \b string\b0 ;
\par     FActive: Boolean;
\par     FBorderIcons: TBorderIcons;
\par     FBorderStyle: TFormBorderStyle;
\par     FKeys: \b array\b0 [\cf0 0\cf1 ..\cf0 255\cf1 ] \b of \b0 Byte;
\par     FMenuName: Integer;
\par     FFullScreen: Boolean;
\par     FPosition: TPosition;
\par     FOnCommand: TCommandEvent;
\par     \b function \b0 GetKey(Index: Integer): Boolean;
\par     \b function \b0 GetCaption: \b string\b0 ;
\par     \b procedure \b0 SetCaption(Value: \b string\b0 );
\par   \b protected
\par     procedure \b0 SetWidth(Value: Integer); \b override\b0 ;
\par     \b procedure \b0 SetHeight(Value: Integer); \b override\b0 ;
\par     \b procedure \b0 SetLeft(Value: Integer); \b override\b0 ;
\par     \b procedure \b0 SetTop(Value: Integer); \b override\b0 ;
\par   \b public
\par     constructor \b0 Create; \b override\b0 ;
\par     \b destructor \b0 Destroy;
\par     \b function \b0 WndProc(hWnd: HWND; uMsg: UINT; wParam: WPARAM; lParam: LPARAM): LRESULT; \b virtual\b0 ;
\par     \b function \b0 Run: Integer;
\par     \b function \b0 HasMessages: Boolean;
\par     \b function \b0 Pump: Boolean;
\par     \b procedure \b0 DoResize;
\par     \b procedure \b0 DoCommand(ID: Integer); \b virtual\b0 ;
\par     \b class function \b0 GetWindow: PWindow;
\par     \b property \b0 Handle: HWnd \b read \b0 FHandle;
\par     \b property \b0 FullScreen: Boolean \b read \b0 FFullScreen \b write \b0 FFullScreen;
\par     \b property \b0 IsActive: Boolean \b read \b0 FActive;
\par     \b property \b0 BorderIcons: TBorderIcons \b read \b0 FBorderIcons \b write \b0 FBorderIcons;
\par     \b property \b0 BorderStyle: TFormBorderStyle \b read \b0 FBorderStyle \b write \b0 FBorderStyle;
\par     \b property \b0 Position: TPosition \b read \b0 FPosition \b write \b0 FPosition;
\par     \b property \b0 Caption: \b string read \b0 GetCaption \b write \b0 SetCaption;
\par     \b property \b0 MenuName: Integer \b read \b0 FMenuName \b write \b0 FMenuName;
\par     \b property \b0 Key[\b Index\b0 : Integer]: Boolean \b read \b0 GetKey;
\par     \b property \b0 OnCommand: TCommandEvent \b read \b0 FOnCommand \b write \b0 FOnCommand;
\par   \b end\b0 ;
\par 
\par  \cf0\i (* EError *)
\par 
\par   \i0\cf1 EError = \b class\b0 (Exception);
\par 
\par  \cf0\i (* ELogError *)
\par 
\par   \i0\cf1 PLogError = ^ELogError;
\par   ELogError = \b class\b0 (EError)
\par   \b public
\par     constructor \b0 Create(\b const \b0 Text: \b string\b0 );
\par   \b end\b0 ;
\par 
\par   \cf0\i (* TFPS *)
\par 
\par   \i0\cf1 PFps = ^TFps;
\par   TFps = \b record
\par     \b0 Time: Cardinal;
\par     Ticks: Cardinal;
\par     FPS: Cardinal;
\par   \b end\b0 ;
\par 
\par   \cf0\i (* TApplication *)
\par 
\par   \i0\cf1 PApplication = ^TApplication;
\par   TApplication = \b class
\par   private
\par     \b0 FHandle: HWND;
\par     FActive: Boolean;
\par     FFps: TFps;
\par     FExeName: \b string\b0 ;
\par     FOnInitialize: TNotifyEvent;
\par     FOnFinalize: TNotifyEvent;
\par     FOnDoFrame: TDoFrameEvent;
\par     FOnDoIdleFrame: TDoFrameEvent;
\par     FOnException: TExceptionEvent;
\par     \b function \b0 GetExeName: \b string\b0 ;
\par   \b protected
\par     procedure \b0 DoInitialize; \b virtual\b0 ;
\par     \b procedure \b0 DoFinalize; \b virtual\b0 ;
\par     \b procedure \b0 DoFrame(TimeDelta: Single); \b virtual\b0 ;
\par     \b procedure \b0 DoIdleFrame(TimeDelta: Single); \b virtual\b0 ;
\par     \b procedure \b0 DoException(E: Exception); \b virtual\b0 ;
\par   \b public
\par     constructor \b0 Create;
\par     \b destructor \b0 Destroy;
\par     \b procedure \b0 Initialize;
\par     \b procedure \b0 CreateForm(InstanceClass: TRefWindow; \b var \b0 Reference);
\par     \b procedure \b0 CreateGraphics(InstanceClass: TRefGraphics; \b var \b0 Reference);
\par     \b function \b0 Run: Integer;
\par     \b procedure \b0 Pause;
\par     \b procedure \b0 UnPause;
\par     \b procedure \b0 Terminate;
\par     \b class function \b0 GetApplication: PApplication;
\par     \b class procedure \b0 KillApplication;
\par     \b property \b0 Active: Boolean \b read \b0 FActive \b write \b0 FActive;
\par     \b property \b0 ExeName: \b string read \b0 GetExeName;
\par     \b property \b0 Handle: HWND \b read \b0 FHandle;
\par     \b property \b0 Fps: Cardinal \b read \b0 FFps.Fps;
\par     \b property \b0 OnInitialize: TNotifyEvent \b read \b0 FOnInitialize \b write \b0 FOnInitialize;
\par     \b property \b0 OnFinalize: TNotifyEvent \b read \b0 FOnFinalize \b write \b0 FOnFinalize;
\par     \b property \b0 OnDoFrame: TDoFrameEvent \b read \b0 FOnDoFrame \b write \b0 FOnDoFrame;
\par     \b property \b0 OnDoIdleFrame: TDoFrameEvent \b read \b0 FOnDoIdleFrame \b write \b0 FOnDoIdleFrame;
\par     \b property \b0 OnException: TExceptionEvent \b read \b0 FOnException \b write \b0 FOnException;
\par   \b end\b0 ;
\par 
\par \b var
\par   \b0 Window: TWindow;
\par   Application: TApplication = \b nil\b0 ;
\par   PictureList: TPictures = \b nil\b0 ;
\par 
\par \b function \b0 SaveLog(\b const \b0 FileName, Text: \b string\b0 ): \b string\b0 ; \b overload\b0 ;
\par \b function \b0 SaveLog(\b const \b0 Text: \b string\b0 ): \b string\b0 ; \b overload\b0 ;
\par \b function \b0 IsNT5OrHigher: Boolean;
\par \b function \b0 OpenFile(Handle: HWnd): \b string\b0 ;
\par \b function \b0 SaveFile(Handle: HWnd): \b string\b0 ;
\par 
\par \b implementation
\par 
\par var
\par   \b0 LogError: PLogError = \b nil\b0 ;
\par 
\par \b function \b0 GlobalWndProc(hWnd: HWND; uMsg: UINT; wParam: WPARAM; lParam: LPARAM): LRESULT; \b stdcall\b0 ;
\par \b begin
\par   \b0 Result := Window.WndProc(hWnd, uMsg, wParam, lParam);
\par \b end\b0 ;
\par 
\par \b constructor \b0 TWindow.Create;
\par \b var
\par   \b0 I: Integer;
\par \b begin
\par   inherited \b0 Create;
\par 
\par   \b if \b0 Assigned(Window) \b then
\par     raise \b0 ELogError.Create(Format(ERROR_EXISTS, [\cf0 'TWindow'\cf1 ]))
\par   \b else
\par     \b0 SaveLog(Format(EVENT_CREATE, [\cf0 'TWindow'\cf1 ]));
\par 
\par   Window := Self;
\par   FHandle := \cf0 0\cf1 ;
\par   FActive := False;
\par   Left := \cf0 0\cf1 ;
\par   Top := \cf0 0\cf1 ;
\par   Width := \cf0 640\cf1 ;
\par   Height := \cf0 480\cf1 ;
\par   ClientRect := Bounds(Left, Top, Width, Height);
\par   FBorderIcons := [biSystemMenu, biMinimize];
\par   FBorderStyle := bsSingle;
\par   ZeroMemory(@FKeys, \cf0 256\cf1 );
\par   FMenuName := \cf0 0\cf1 ;
\par   FFullScreen := False;
\par   FCaption := \cf0 'Window'\cf1 ;
\par 
\par   \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par     \b0 TControl(ControlList[I]).DoCreate;
\par \b end\b0 ;
\par 
\par \b destructor \b0 TWindow.Destroy;
\par \b var
\par   \b0 I: Integer;
\par \b begin
\par   for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par     \b0 TControl(ControlList[I]).DoFinalize;
\par   DestroyWindow(Handle);
\par   Window := \b nil\b0 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TWindow.WndProc(hWnd: HWND; uMsg: UINT; wParam: WPARAM; lParam: LPARAM): LRESULT;
\par \b var
\par   \b0 MouseMessage: TWMMouse;
\par   KeyboardMessage: TWMKey;
\par   I: Integer;
\par 
\par   \b procedure \b0 UpdateMouse;
\par   \b begin
\par     \b0 MouseMessage.Msg := uMsg;
\par     MouseMessage.Keys := wParam;
\par     MouseMessage.XPos := LOWORD(lParam);
\par     MouseMessage.YPos := HIWORD(lParam);
\par   \b end\b0 ;
\par 
\par   \b procedure \b0 UpdateKeyboard;
\par   \b begin
\par     \b0 KeyboardMessage.Msg := uMsg;
\par     KeyboardMessage.CharCode := wParam;
\par     KeyboardMessage.KeyData := Integer(@FKeys);
\par   \b end\b0 ;
\par 
\par \b begin
\par   if \b0 Assigned(LogError) \b then
\par   begin
\par     \b0 Result := DefWindowProc(hWnd, uMsg, wParam, lParam);
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b try
\par     case \b0 uMsg \b of
\par 
\par       \b0 WM_CREATE:
\par         \b begin
\par           \b0 Window.FActive := True;
\par         \b end\b0 ;
\par 
\par       WM_PAINT:
\par         \b begin
\par           \b0 ValidateRect(hWnd, \b nil\b0 );
\par         \b end\b0 ;
\par 
\par       WM_MOVE:
\par         \b begin
\par           \b0 ClientRect.Left := LOWORD(lParam);
\par           ClientRect.Top := HIWORD(lParam);
\par         \b end\b0 ;
\par 
\par       WM_SIZE:
\par         \b begin
\par           \b0 DoResize;
\par         \b end\b0 ;
\par 
\par       WM_KEYDOWN:
\par         \b begin
\par           \b0 FKeys[wParam] := \cf0 1\cf1 ;
\par           UpdateKeyboard;
\par           \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par             \b0 TControl(ControlList[I]).KeyDown(KeyboardMessage);
\par         \b end\b0 ;
\par 
\par       WM_CHAR:
\par         \b begin
\par           \b0 FKeys[wParam] := \cf0 1\cf1 ;
\par           UpdateKeyboard;
\par           \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par             \b0 TControl(ControlList[I]).KeyPress(KeyboardMessage);
\par         \b end\b0 ;
\par 
\par       WM_KEYUP:
\par         \b begin
\par           \b0 FKeys[wParam] := \cf0 0\cf1 ;
\par           UpdateKeyboard;
\par           \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par             \b0 TControl(ControlList[I]).KeyUp(KeyboardMessage);
\par         \b end\b0 ;
\par 
\par       WM_LBUTTONDOWN:
\par         \b begin
\par           \b0 DoClick;
\par           UpdateMouse;
\par           \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par             \b0 TControl(ControlList[I]).MouseDown(MouseMessage, mbLeft, []);
\par         \b end\b0 ;
\par 
\par       WM_LBUTTONDBLCLK:
\par         \b begin
\par           for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par             \b0 TControl(ControlList[I]).DoDblClick;
\par         \b end\b0 ;
\par 
\par       WM_LBUTTONUP:
\par         \b begin
\par           \b0 UpdateMouse;
\par           \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par             \b0 TControl(ControlList[I]).MouseUp(MouseMessage, mbLeft);
\par         \b end\b0 ;
\par 
\par       WM_RBUTTONDOWN:
\par         \b begin
\par           \b0 UpdateMouse;
\par           \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par             \b0 TControl(ControlList[I]).MouseDown(MouseMessage, mbRight, []);
\par         \b end\b0 ;
\par 
\par       WM_RBUTTONUP:
\par         \b begin
\par           \b0 UpdateMouse;
\par           \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par             \b0 TControl(ControlList[I]).MouseUp(MouseMessage, mbRight);
\par         \b end\b0 ;
\par 
\par       WM_MOUSEMOVE:
\par         \b begin
\par           \b0 UpdateMouse;
\par           \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par             \b0 TControl(ControlList[I]).MouseMove(MouseMessage);
\par         \b end\b0 ;
\par 
\par       WM_COMMAND:
\par         \b begin
\par           \b0 DoCommand(LOWORD(wParam));
\par         \b end\b0 ;
\par 
\par       WM_DESTROY, WM_CLOSE:
\par         \b begin
\par           \b0 PostQuitMessage(\cf0 0\cf1 );
\par         \b end\b0 ;
\par 
\par       WM_SETFOCUS:
\par         \b begin
\par           if \b0 Assigned(Input) \b then
\par           begin
\par             \b0 Input.MouseAcquire(True);
\par             Input.KeyboardAcquire(True);
\par           \b end\b0 ;
\par 
\par           Application.Active := True;
\par         \b end\b0 ;
\par 
\par       WM_KILLFOCUS:
\par         \b begin
\par           if \b0 Assigned(Input) \b then
\par           begin
\par             \b0 Input.MouseAcquire(False);
\par             Input.KeyboardAcquire(False);
\par           \b end\b0 ;
\par 
\par           Application.Active := False;
\par         \b end\b0 ;
\par 
\par     \b else
\par       begin
\par         \b0 Result := DefWindowProc(hWnd, uMsg, wParam, lParam);
\par         Exit;
\par       \b end\b0 ;
\par     \b end\b0 ;
\par 
\par   \b except
\par     \b0 New(LogError);
\par     Result := \cf0 0\cf1 ;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   Result := \cf0 0\cf1 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TWindow.Run: Integer;
\par \b var
\par   \b0 Wc: TWndClass;
\par   Style: Integer;
\par   I: Integer;
\par \b begin
\par   \b0 Result := E_FAIL;
\par 
\par   SaveLog(Format(EVENT_TALK, [\cf0 'TWindow.Run'\cf1 ]));
\par 
\par   Style := \cf0 0\cf1 ;
\par 
\par   \b if \b0 FullScreen \b then
\par     \b0 Style := Style \b or \b0 WS_POPUP;
\par 
\par   \b if \b0 biSystemMenu \b in \b0 FBorderIcons \b then
\par     \b0 Style := Style \b or \b0 WS_SYSMENU;
\par 
\par   \b if \b0 biMinimize \b in \b0 FBorderIcons \b then
\par     \b0 Style := Style \b or \b0 WS_MINIMIZEBOX;
\par 
\par   \b if \b0 biMaximize \b in \b0 FBorderIcons \b then
\par     \b0 Style := Style \b or \b0 WS_MAXIMIZEBOX;
\par 
\par   \b if \b0 biHelp \b in \b0 FBorderIcons \b then
\par     \b0 Style := Style \b or \b0 WS_EX_CONTEXTHELP;
\par 
\par   \b case \b0 FBorderStyle \b of
\par     \b0 bsNone:
\par       \b begin
\par         \b0 Style := Style \b or \b0 WS_POPUP;
\par         BorderIcons := [];
\par       \b end\b0 ;
\par     bsSingle, bsToolWindow:
\par       Style := Style \b or \b0 (WS_CAPTION \b or \b0 WS_BORDER);
\par     bsSizeable, bsSizeToolWin:
\par       \b begin
\par         \b0 Style := Style \b or \b0 (WS_CAPTION \b or \b0 WS_THICKFRAME);
\par       \b end\b0 ;
\par     bsDialog:
\par       \b begin
\par         \b0 Style := Style \b or \b0 WS_POPUP \b or \b0 WS_CAPTION;
\par       \b end\b0 ;
\par   \b end\b0 ;
\par 
\par   \b case \b0 FPosition \b of
\par     \b0 poLeft: ClientRect.Left := \cf0 0\cf1 ;
\par     poTop: ClientRect.Top := \cf0 0\cf1 ;
\par     poRight: ClientRect.Left := GetSystemMetrics(SM_CXSCREEN) - ClientRect.Right;
\par     poDown: ClientRect.Top := GetSystemMetrics(SM_CYSCREEN) - ClientRect.Bottom;
\par     poCenter:
\par       \b begin
\par         \b0 ClientRect.Left := (GetSystemMetrics(SM_CXSCREEN) - ClientRect.Right) \b div \b0\cf0 2\cf1 ;
\par         ClientRect.Top := (GetSystemMetrics(SM_CYSCREEN) - ClientRect.Bottom) \b div \b0\cf0 2\cf1 ;
\par       \b end\b0 ;
\par   \b end\b0 ;
\par 
\par   FillChar(Wc, SizeOf(TWndClass), \cf0 0\cf1 );
\par   Wc.lpszClassName := PChar(FCaption);
\par   Wc.lpfnWndProc := @GlobalWndProc;
\par   Wc.style := CS_VREDRAW \b or \b0 CS_HREDRAW;
\par   Wc.hInstance := HInstance;
\par   Wc.hIcon := LoadIcon(\cf0 0\cf1 , IDI_WINLOGO);
\par   Wc.hCursor := LoadCursor(\cf0 0\cf1 , IDC_ARROW);
\par   Wc.hbrBackground := GetStockObject(BLACK_BRUSH);
\par   \b if \b0 FMenuName <> \cf0 0 \cf1\b then
\par     \b0 Wc.lpszMenuName := MakeIntResource(FMenuName)
\par   \b else
\par     \b0 Wc.lpszMenuName := \b nil\b0 ;
\par   Wc.cbClsExtra := \cf0 0\cf1 ;
\par   Wc.cbWndExtra := \cf0 0\cf1 ;
\par 
\par   \b if \b0 Windows.RegisterClass(Wc) = \cf0 0 \cf1\b then
\par     raise \b0 ELogError.Create(ERROR_REGISTRY);
\par 
\par   AdjustWindowRect(ClientRect, Style, False);
\par 
\par   FHandle := CreateWindow(PChar(FCaption), PChar(FCaption), Style \b or \b0 WS_VISIBLE, ClientRect.Left,
\par     ClientRect.Top, ClientRect.Right, ClientRect.Bottom, \cf0 0\cf1 , \cf0 0\cf1 , HInstance, \b nil\b0 );
\par   \b if \b0 FHandle = \cf0 0 \cf1\b then
\par     raise \b0 ELogError.Create(ERROR_INSTANCE)
\par   \b else
\par     \b0 Result := S_OK;
\par 
\par   SaveLog(Format(EVENT_WINDOW, [ClientRect.Left, ClientRect.Top, ClientRect.Right, ClientRect.Bottom, FCaption]));
\par 
\par   \b for \b0 I := \cf0 0 \cf1\b to \b0 ControlList.Count - \cf0 1 \cf1\b do
\par     \b0 TControl(ControlList[I]).DoInitialize;
\par 
\par   \b if not \b0 FullScreen \b then
\par     \b0 ShowWindow(Handle, SW_SHOW);
\par 
\par   UpdateWindow(Handle);
\par \b end\b0 ;
\par 
\par \b function \b0 TWindow.HasMessages: Boolean;
\par \b var
\par   \b0 Msg: TMsg;
\par \b begin
\par   \b0 Result := PeekMessage(Msg, \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , PM_NOREMOVE);
\par \b end\b0 ;
\par 
\par \b function \b0 TWindow.Pump: Boolean;
\par \b var
\par   \b0 Msg: TMsg;
\par   ErrorOut: ELogError;
\par \b begin
\par   \b0 PeekMessage(Msg, \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , PM_REMOVE);
\par 
\par   \b if \b0 Msg.\b message \b0 = WM_QUIT \b then
\par   begin
\par     \b0 Result := False;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   TranslateMessage(Msg);
\par   DispatchMessage(Msg);
\par 
\par   \b if \b0 Assigned(LogError) \b then
\par   begin
\par     \b0 ErrorOut := LogError^;
\par     Dispose(LogError);
\par     \b raise \b0 ELogError.Create(Format(EVENT_ERROR, [\cf0 'TWindow.Pump'\cf1 ]));
\par   \b end\b0 ;
\par 
\par   Result := True;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TWindow.DoResize;
\par \b begin
\par   \b0 GetWindowRect(Handle, ClientRect);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TWindow.SetWidth(Value: Integer);
\par \b begin
\par   inherited \b0 SetWidth(Value);
\par   MoveWindow(Handle, ClientRect.Left, ClientRect.Top,
\par     ClientRect.Right, ClientRect.Bottom, True);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TWindow.SetHeight(Value: Integer);
\par \b begin
\par   inherited \b0 SetHeight(Value);
\par   MoveWindow(Handle, ClientRect.Left, ClientRect.Top,
\par     ClientRect.Right, ClientRect.Bottom, True);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TWindow.SetLeft(Value: Integer);
\par \b begin
\par   inherited \b0 SetLeft(Value);
\par   MoveWindow(Handle, ClientRect.Left, ClientRect.Top,
\par     ClientRect.Right, ClientRect.Bottom, True);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TWindow.SetTop(Value: Integer);
\par \b begin
\par   inherited \b0 SetTop(Value);
\par   MoveWindow(Handle, ClientRect.Left, ClientRect.Top,
\par     ClientRect.Right, ClientRect.Bottom, True);
\par \b end\b0 ;
\par 
\par \b function \b0 TWindow.GetKey(Index: Integer): Boolean;
\par \b begin
\par   \b0 Result := FKeys[Index] <> \cf0 0\cf1 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TWindow.GetCaption: \b string\b0 ;
\par \b begin
\par   \b0 GetWindowText(Handle, PChar(FCaption), \cf0 255\cf1 );
\par   Result := FCaption;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TWindow.SetCaption(Value: \b string\b0 );
\par \b begin
\par   if \b0 FCaption <> Value \b then
\par   begin
\par     \b0 FCaption := Value;
\par     SetWindowText(Handle, PChar(FCaption));
\par   \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TWindow.DoCommand(ID: Integer);
\par \b begin
\par   if \b0 Assigned(FOnCommand) \b then \b0 FOnCommand(Self, ID);
\par \b end\b0 ;
\par 
\par \b class function \b0 TWindow.GetWindow: PWindow;
\par \b begin
\par   \b0 Result := @Window;
\par \b end\b0 ;
\par 
\par \b function \b0 SaveLog(\b const \b0 FileName, Text: \b string\b0 ): \b string\b0 ;
\par \b var
\par   \b0 FileLog: TextFile;
\par \b begin
\par   \b0 AssignFile(FileLog, FileName);
\par 
\par   \b if \b0 FileExists(FileName) \b then
\par     \b0 Append(FileLog)
\par   \b else
\par     \b0 Rewrite(FileLog);
\par 
\par   \b try
\par     \b0 Writeln(FileLog, Text);
\par   \b finally
\par     \b0 CloseFile(FileLog);
\par   \b end\b0 ;
\par 
\par   Result := Text;
\par \b end\b0 ;
\par 
\par \b function \b0 SaveLog(\b const \b0 Text: \b string\b0 ): \b string\b0 ;
\par \b begin
\par   \b0 Result := SaveLog(FILE_LOG, DateTimeToStr(Now) + \cf0 ': ' \cf1 + Text);
\par \b end\b0 ;
\par 
\par \b function \b0 IsNT5OrHigher: Boolean;
\par \b var
\par   \b0 Ovi: TOSVERSIONINFO;
\par \b begin
\par   \b0 ZeroMemory(@Ovi, SizeOf(TOSVERSIONINFO));
\par   Ovi.dwOSVersionInfoSize := SizeOf(TOSVERSIONINFO);
\par   GetVersionEx(Ovi);
\par   \b if \b0 (Ovi.dwPlatformId = VER_PLATFORM_WIN32_NT) \b and \b0 (ovi.dwMajorVersion >= \cf0 5\cf1 ) \b then
\par     \b0 Result := True
\par   \b else
\par     \b0 Result := False;
\par \b end\b0 ;
\par 
\par \b function \b0 OpenFile(Handle: HWnd): \b string\b0 ;
\par \b var
\par   \b0 Ofn: TOpenFilename;
\par   Buffer: \b array\b0 [\cf0 0\cf1 ..MAX_PATH - \cf0 1\cf1 ] \b of \b0 Char;
\par \b begin
\par   \b0 Result := \cf0 ''\cf1 ;
\par   ZeroMemory(@Buffer[\cf0 0\cf1 ], SizeOf(Buffer));
\par   ZeroMemory(@Ofn, SizeOf(TOpenFilename));
\par   \b if \b0 IsNt5OrHigher \b then
\par     \b0 Ofn.lStructSize := SizeOf(TOpenFilename)
\par   \b else
\par     \b0 Ofn.lStructSize := OPENFILENAME_SIZE_VERSION_400;
\par   Ofn.hWndOwner := Handle;
\par   Ofn.hInstance := hInstance;
\par   Ofn.lpstrFile := @Buffer[\cf0 0\cf1 ];
\par   Ofn.lpstrFilter := FILTER_MAP;
\par   Ofn.nMaxFile := SizeOf(Buffer);
\par   Ofn.Flags := OFN_FILEMUSTEXIST \b or \b0 OFN_PATHMUSTEXIST \b or \b0 OFN_LONGNAMES \b or
\par     \b0 OFN_EXPLORER \b or \b0 OFN_HIDEREADONLY;
\par 
\par   \b if \b0 GetOpenFileName(Ofn) \b then
\par     \b0 Result := Ofn.lpstrFile;
\par \b end\b0 ;
\par 
\par \b function \b0 SaveFile(Handle: HWnd): \b string\b0 ;
\par \b var
\par   \b0 Ofn: TOpenFilename;
\par   Buffer: \b array\b0 [\cf0 0\cf1 ..MAX_PATH - \cf0 1\cf1 ] \b of \b0 Char;
\par \b begin
\par   \b0 Result := \cf0 ''\cf1 ;
\par   ZeroMemory(@Buffer[\cf0 0\cf1 ], SizeOf(Buffer));
\par   ZeroMemory(@Ofn, SizeOf(TOpenFilename));
\par   \b if \b0 IsNt5OrHigher \b then
\par     \b0 Ofn.lStructSize := SizeOf(TOpenFilename)
\par   \b else
\par     \b0 Ofn.lStructSize := OPENFILENAME_SIZE_VERSION_400;
\par   Ofn.hWndOwner := Handle;
\par   Ofn.hInstance := hInstance;
\par   Ofn.lpstrFile := @Buffer[\cf0 0\cf1 ];
\par   Ofn.lpstrFilter := FILTER_MAP;
\par   Ofn.nMaxFile := SizeOf(Buffer);
\par   Ofn.Flags := OFN_FILEMUSTEXIST \b or \b0 OFN_PATHMUSTEXIST \b or \b0 OFN_LONGNAMES \b or
\par     \b0 OFN_EXPLORER \b or \b0 OFN_HIDEREADONLY;
\par 
\par   \b if \b0 GetSaveFileName(Ofn) \b then
\par     \b0 Result := Ofn.lpstrFile;
\par \b end\b0 ;
\par 
\par  \cf0\i (* ELogError *)
\par 
\par \i0\cf1\b constructor \b0 ELogError.Create(\b const \b0 Text: \b string\b0 );
\par \b begin
\par   Message \b0 := SaveLog(Text);
\par \b end\b0 ;
\par 
\par   \cf0\i (* TApplication *)
\par 
\par \i0\cf1\b constructor \b0 TApplication.Create;
\par \b begin
\par   if \b0 Assigned(Application) \b then
\par     raise \b0 ELogError.Create(Format(ERROR_EXISTS, [\cf0 'TApplication'\cf1 ]))
\par   \b else
\par     \b0 SaveLog(Format(EVENT_CREATE, [\cf0 'TApplication'\cf1 ]));
\par 
\par   Application := Self;
\par   FHandle := \cf0 0\cf1 ;
\par   FActive := True;
\par   FFPS.Time := \cf0 0\cf1 ;
\par   FFPS.Ticks := \cf0 0\cf1 ;
\par   FFPS.FPS := \cf0 0\cf1 ;
\par \b end\b0 ;
\par 
\par \b destructor \b0 TApplication.Destroy;
\par \b begin
\par   \b0 TWindow.GetWindow^.Free;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.Initialize;
\par \b begin
\par   \b0 FExeName := ParamStr(\cf0 0\cf1 );
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.CreateForm(InstanceClass: TRefWindow; \b var \b0 Reference);
\par \b begin
\par   try
\par     \b0 TWindow(Reference) := InstanceClass.Create;
\par     TWindow(Reference).Run;
\par     FHandle := TWindow(Reference).Handle;
\par   \b except
\par     on \b0 E: Exception \b do
\par       \b0 SaveLog(Format(EVENT_ERROR, [E.\b Message\b0 ]));
\par   \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.CreateGraphics(InstanceClass: TRefGraphics; \b var \b0 Reference);
\par \b begin
\par   try
\par     \b0 TGraphics(Reference) := InstanceClass.Create;
\par     TGraphics(Reference).Run;
\par     PictureList := TPictures.Create(TPicture);
\par     \b with \b0 PictureList.Add \b do
\par     begin
\par       \b0 Name := \cf0 'Colors'\cf1 ;
\par       PatternWidth := \cf0 1\cf1 ;
\par       PatternHeight := \cf0 1\cf1 ;
\par       SkipWidth := \cf0 0\cf1 ;
\par       SkipHeight := \cf0 0\cf1 ;
\par       TransparentColor := \cf0 0\cf1 ;
\par       FileName := \cf0 'Colors.bmp'\cf1 ;
\par     \b end\b0 ;
\par   \b except
\par     on \b0 E: Exception \b do
\par       \b0 SaveLog(Format(EVENT_ERROR, [E.\b Message\b0 ]));
\par   \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TApplication.Run: Integer;
\par \b var
\par   \b0 Done: Boolean;
\par   LastTime, CurrTime, Delta: Single;
\par \b begin
\par   \b0 SaveLog(Format(EVENT_TALK, [\cf0 'TApplication.Run'\cf1 ]));
\par 
\par   Done := False;
\par   LastTime := TimeGetTime;
\par 
\par   \b try
\par     \b0 DoInitialize;
\par 
\par     SaveLog(Format(EVENT_APPLICATION, [ExtractFileName(ExeName)]));
\par 
\par     \b while not \b0 Done \b do
\par     begin
\par       while \b0 (\b not \b0 Done) \b and \b0 (Window.HasMessages) \b do
\par         if not \b0 Window.Pump \b then
\par           \b0 Done := True;
\par 
\par       CurrTime := TimeGetTime;
\par       Delta := (CurrTime - LastTime) / \cf0 1000.0\cf1 ;
\par 
\par       Inc(FFPs.Ticks);
\par       \b if \b0 (FFPs.Time + \cf0 1000\cf1 ) <= GetTickCount \b then
\par       begin
\par         \b0 FFPS.FPS := FFPS.Ticks;
\par         FFPS.Ticks := \cf0 0\cf1 ;
\par         FFPS.Time := GetTickCount;
\par       \b end\b0 ;
\par 
\par       \b if \b0 FActive \b then
\par         \b0 DoFrame(Delta)
\par       \b else
\par         \b0 DoIdleFrame(Delta);
\par 
\par       LastTime := CurrTime;
\par     \b end\b0 ;
\par 
\par   \b except
\par     on \b0 E: Exception \b do
\par     begin
\par       \b0 DoException(E);
\par       SaveLog(Format(EVENT_ERROR, [E.\b Message\b0 ]));
\par       Application.Free;
\par       ExitCode := \cf0 0\cf1 ;
\par       Result := \cf0 0\cf1 ;
\par       Exit;
\par     \b end\b0 ;
\par   \b end\b0 ;
\par 
\par   Application.Free;
\par 
\par   ExitCode := \cf0 0\cf1 ;
\par   Result := \cf0 0\cf1 ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.Pause;
\par \b begin
\par   \b0 FActive := False;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.UnPause;
\par \b begin
\par   \b0 FActive := True;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.Terminate;
\par \b begin
\par   \b0 PostQuitMessage(\cf0 0\cf1 );
\par \b end\b0 ;
\par 
\par \b function \b0 TApplication.GetExeName: \b string\b0 ;
\par \b begin
\par   \b0 Result := FExeName;
\par \b end\b0 ;
\par 
\par \b class function \b0 TApplication.GetApplication: PApplication;
\par \b begin
\par   \b0 Result := @Application;
\par \b end\b0 ;
\par 
\par \b class procedure \b0 TApplication.KillApplication;
\par \b begin
\par   \b0 Application.Free;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.DoInitialize;
\par \b begin
\par   if \b0 Assigned(FOnInitialize) \b then \b0 FOnInitialize(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.DoFinalize;
\par \b begin
\par   if \b0 Assigned(FOnFinalize) \b then \b0 FOnFinalize(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.DoFrame;
\par \b begin
\par   if \b0 Assigned(FOnDoFrame) \b then \b0 FOnDoFrame(Self, TimeDelta);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.DoIdleFrame;
\par \b begin
\par   if \b0 Assigned(FOnDoIdleFrame) \b then \b0 FOnDoIdleFrame(Self, TimeDelta);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TApplication.DoException;
\par \b begin
\par   if \b0 Assigned(FOnException) \b then \b0 FOnException(Self, E);
\par \b end\b0 ;
\par 
\par \b initialization
\par   \b0 SaveLog(FILE_LOG, EVENT_START);
\par   Application := TApplication.Create;
\par 
\par \b end\b0 .
\par 
\par }
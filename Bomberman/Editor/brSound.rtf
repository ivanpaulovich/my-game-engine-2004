{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue128;\red0\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title brSound.rtf}}

\deflang1033\pard\plain\f0\fs20 \cf0\i (*******************************************************)
\par (*                                                     *)
\par (*       Engine Paulovich DirectX                      *)
\par (*       Win32-DirectX API Unit                        *)
\par (*                                                     *)
\par (*       Copyright (c) 2003-2004, Ivan Paulovich       *)
\par (*                                                     *)
\par (*       iskatrek@hotmail.com  uin#89160524            *)
\par (*                                                     *)
\par (*       Unit: brSound                                 *)
\par (*                                                     *)
\par (*******************************************************)
\par 
\par \i0\cf1\b unit \b0 brSound;
\par 
\par \b interface
\par 
\par uses
\par   \b0 Windows, Classes, SysUtils, ActiveX, DirectMusic, DXUtil;
\par 
\par \b const
\par   \b0 SOUNDERROR_MUSICLOADER = \cf0 $85000001\cf1 ;
\par   SOUNDERROR_MUSICPERFORMANCE = \cf0 $85000002\cf1 ;
\par   SOUNDERROR_INITAUDIO = \cf0 $85000003\cf1 ;
\par   SOUNDERROR_PATH = \cf0 $85000004\cf1 ;
\par   SOUNDERROR_VOLUME = \cf0 $85000005\cf1 ;
\par   SOUNDERROR_LOAD = \cf0 $85000006\cf1 ;
\par   SOUNDERROR_DOWNLOAD = \cf0 $85000007\cf1 ;
\par   SOUNDERROR_NOSEGMENT = \cf0 $85000008\cf1 ;
\par   SOUNDERROR_PLAYFAIL = \cf0 $85000009\cf1 ;
\par 
\par \b type
\par 
\par   \b0\cf0\i (* TSound *)
\par 
\par   \i0\cf1 PSound = ^TSound;
\par   TSound = \b class\b0 (TCollectionItem)
\par   \b private
\par     \b0 FName: \b string\b0 [\cf0 255\cf1 ];
\par     FFileName: \b string\b0 [\cf0 255\cf1 ];
\par     FSound: IDirectMusicSegment8;
\par     FLoader: IDirectMusicLoader8;
\par     FPerformance: IDirectMusicPerformance8;
\par     \b function \b0 InitSoundSystem: HRESULT;
\par     \b function \b0 GetName: \b string\b0 ;
\par     \b procedure \b0 SetName(Value: \b string\b0 );
\par     \b function \b0 GetFileName: \b string\b0 ;
\par     \b procedure \b0 SetFileName(Value: \b string\b0 );
\par   \b public
\par     constructor \b0 Create(Collection: TCollection); \b override\b0 ;
\par     \b destructor \b0 Destroy;
\par     \b function \b0 LoadFromFile(FileSound: \b string\b0 ): Boolean;
\par     \b function \b0 Play: Boolean;
\par     \b function \b0 Stop: Boolean;
\par     \b property \b0 Name: \b string read \b0 GetName \b write \b0 SetName;
\par     \b property \b0 FileName: \b string read \b0 GetFileName \b write \b0 SetFileName;
\par   \b end\b0 ;
\par 
\par   \cf0\i (* TSounds *)
\par 
\par   \i0\cf1 TSounds = \b class\b0 (TCollection)
\par   \b private
\par     function \b0 IndexOf(Name: \b string\b0 ): TSound;
\par     \b function \b0 GetItem(Index: Integer): TSound;
\par   \b public
\par     function \b0 Add: TSound;
\par     \b function \b0 AddEx(FileName: \b string\b0 ; Name: \b string\b0 ): TSound;
\par     \b function \b0 Find(\b const \b0 Name: \b string\b0 ): TSound;
\par     \b property \b0 Item[\b Index\b0 : Integer]: TSound \b read \b0 GetItem;
\par   \b end\b0 ;
\par 
\par \b implementation
\par 
\par uses
\par   \b0 brForms;
\par 
\par \b var
\par   \b0 Initialized: Boolean = False;
\par   
\par \b constructor \b0 TSound.Create;
\par \b begin
\par   inherited \b0 Create(Collection);
\par 
\par   FSound := \b nil\b0 ;
\par   FLoader := \b nil\b0 ;
\par   FPerformance := \b nil\b0 ;
\par   \b if not \b0 Initialized \b then
\par     \b0 InitSoundSystem;
\par \b end\b0 ;
\par 
\par \b destructor \b0 TSound.Destroy;
\par \b begin
\par   if \b0 Assigned(FSound) \b then
\par     if \b0 Assigned(FPerformance) \b then
\par       \b0 FSound.Unload(FPerformance);
\par 
\par   FSound := \b nil\b0 ;
\par   FLoader := \b nil\b0 ;
\par   FPerformance := \b nil\b0 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TSound.InitSoundSystem: HRESULT;
\par \b var
\par   \b0 FPath: IDirectMusicAudioPath8;
\par \b begin
\par   \b0 CoInitialize(\b nil\b0 );
\par 
\par   \b if \b0 (Failed(CoCreateInstance(CLSID_DirectMusicLoader, \b nil\b0 ,
\par     CLSCTX_INPROC, IID_IDirectMusicLoader8, FLoader))) \b then
\par   begin
\par     \b0 Result := SOUNDERROR_MUSICLOADER;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 (Failed(CoCreateInstance(CLSID_DirectMusicPerformance, \b nil\b0 ,
\par     CLSCTX_INPROC, IID_IDirectMusicPerformance8, FPerformance))) \b then
\par   begin
\par     \b0 Result := SOUNDERROR_MUSICPERFORMANCE;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 (Failed(FPerformance.InitAudio(\b nil\b0 , \b nil\b0 , Window.Handle, DMUS_APATH_DYNAMIC_STEREO,
\par     \cf0 4\cf1 , DMUS_AUDIOF_ALL, \b nil\b0 ))) \b then
\par   begin
\par     \b0 Result := SOUNDERROR_INITAUDIO;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 (Failed(FPerformance.GetDefaultAudioPath(FPath))) \b then
\par   begin
\par     \b0 Result := SOUNDERROR_PATH;
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 (Failed(FPath.SetVolume(\cf0 0\cf1 , \cf0 0\cf1 ))) \b then
\par   begin
\par     \b0 Result := SOUNDERROR_VOLUME;
\par   \b end\b0 ;
\par 
\par   Initialized := True;
\par   Result := S_OK;
\par \b end\b0 ;
\par 
\par \b function \b0 TSound.LoadFromFile(FileSound: \b string\b0 ): Boolean;
\par \b var
\par   \b0 WFileName: \b array\b0 [\cf0 0\cf1 ..\cf0 511\cf1 ] \b of \b0 WChar;
\par \b begin
\par   \b0 Result := False;
\par 
\par   \b if \b0 FileExists(FileSound) \b then
\par     \b0 SaveLog(Format(EVENT_FOUND, [FileSound]))
\par   \b else
\par     raise \b0 EError.Create(Format(ERROR_NOTFOUND, [FileSound]));
\par 
\par   FFileName := FileSound;
\par 
\par   \b if not \b0 Assigned(FLoader) \b then
\par   begin
\par     raise \b0 EError.Create(ERROR_MUSICLOADER);
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if not \b0 Assigned(FPerformance) \b then
\par   begin
\par     raise \b0 EError.Create(ERROR_MUSICPERFORMANCE);
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 Assigned(FSound) \b then
\par   begin
\par     \b0 FSound.Unload(FPerformance);
\par     FSound._Release;
\par     FSound := \b nil\b0 ;
\par   \b end\b0 ;
\par 
\par   DXUtil_ConvertGenericStringToWide(WFileName, PChar(FileSound), \cf0 512\cf1 );
\par 
\par   \b if \b0 (FAILED(FLoader.LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment8,
\par     WFileName, FSound))) \b then
\par   begin
\par     raise \b0 EError.Create(ERROR_LOAD);
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 (FAILED(FSound.Download(FPerformance))) \b then
\par   begin
\par     raise \b0 EError.Create(ERROR_DOWNLOAD);
\par     Exit;
\par   \b end\b0 ;
\par 
\par   Result := True;
\par \b end\b0 ;
\par 
\par \b function \b0 TSound.Play;
\par \b begin
\par   \b0 Result := False;
\par 
\par   \b if not \b0 Assigned(FPerformance) \b then
\par   begin
\par     raise \b0 EError.Create(ERROR_MUSICPERFORMANCE);
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if not \b0 Assigned(FSound) \b then
\par   begin
\par     raise \b0 EError.Create(ERROR_NOSEGMENT);
\par     Exit;
\par   \b end\b0 ;
\par 
\par   \b if \b0 Failed(FPerformance.PlaySegment(FSound, DMUS_SEGF_DEFAULT \b or \b0 DMUS_SEGF_SECONDARY, \cf0 0\cf1 , \b nil\b0 )) \b then
\par   begin
\par     raise \b0 EError.Create(ERROR_PLAYFAIL);
\par     Exit;
\par   \b end\b0 ;
\par 
\par   Result := True;
\par \b end\b0 ;
\par 
\par \b function \b0 TSound.Stop;
\par \b begin
\par   \b0 Result := FPerformance.Stop(FSound, \b nil\b0 , \cf0 0\cf1 , \cf0 0\cf1 ) = S_OK;
\par \b end\b0 ;
\par 
\par \b function \b0 TSound.GetName: \b string\b0 ;
\par \b begin
\par   \b0 Result := FName;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TSound.SetName(Value: \b string\b0 );
\par \b begin
\par   \b0 FName := Value;
\par \b end\b0 ;
\par 
\par \b function \b0 TSound.GetFileName: \b string\b0 ;
\par \b begin
\par   \b0 Result := FileName;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TSound.SetFileName(Value: \b string\b0 );
\par \b begin
\par   \b0 FFileName := Value;
\par   LoadFromFile(Value);
\par \b end\b0 ;
\par 
\par \b function \b0 TSounds.IndexOf(Name: \b string\b0 ): TSound;
\par \b var
\par   \b0 I: Integer;
\par \b begin
\par   for \b0 I := \cf0 0 \cf1\b to \b0 Count - \cf0 1 \cf1\b do
\par   begin
\par     if \b0 GetItem(I).Name = Name \b then
\par     begin
\par       \b0 Result := GetItem(I);
\par       Exit;
\par     \b end\b0 ;
\par   \b end\b0 ;
\par 
\par   Result := \b nil\b0 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TSounds.GetItem(Index: Integer): TSound;
\par \b begin
\par   \b0 Result := \b inherited \b0 Items[Index] \b as \b0 TSound;
\par \b end\b0 ;
\par 
\par \b function \b0 TSounds.Add: TSound;
\par \b begin
\par   \b0 Result := \b inherited \b0 Add \b as \b0 TSound;
\par \b end\b0 ;
\par 
\par \b function \b0 TSounds.AddEx(FileName: \b string\b0 ; Name: \b string\b0 ): TSound;
\par \b begin
\par   \b0 Result := \b inherited \b0 Add \b as \b0 TSound;
\par   Result.Name := Name;
\par   Result.FFileName := FileName;
\par   Result.LoadFromFile(FileName);
\par \b end\b0 ;
\par 
\par \b function \b0 TSounds.Find(\b const \b0 Name: \b string\b0 ): TSound;
\par \b begin
\par   \b0 Result := IndexOf(Name);
\par   \b if \b0 Result = \b nil then
\par     raise \b0 EError.Create(Format(ERROR_NOTFOUND, [Name]));
\par \b end\b0 ;
\par 
\par \b end\b0 .
\par }
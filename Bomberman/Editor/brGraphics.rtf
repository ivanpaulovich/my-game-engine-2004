{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue128;\red0\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title brGraphics.rtf}}

\deflang1033\pard\plain\f0\fs20 \cf0\i (*******************************************************)
\par (*                                                     *)
\par (*       Engine Paulovich DirectX                      *)
\par (*       Win32-DirectX API Unit                        *)
\par (*                                                     *)
\par (*       Copyright (c) 2003-2004, Ivan Paulovich       *)
\par (*                                                     *)
\par (*       iskatrek@hotmail.com  uin#89160524            *)
\par (*                                                     *)
\par (*       Unit: brGraphics                              *)
\par (*                                                     *)
\par (*******************************************************)
\par 
\par \i0\cf1\b unit \b0 brGraphics;
\par 
\par \b interface
\par 
\par uses
\par   \b0 Windows, SysUtils, Classes, brControls,
\par   D3DX8, \cf0\i \{$IFDEF DXG_COMPAT\}\i0\cf1 DirectXGraphics\cf0\i \{$ELSE\}\i0\cf1 Direct3D8\cf0\i \{$ENDIF\}\i0\cf1 ;
\par 
\par \b type
\par 
\par   \b0\cf0\i (* Pre-Declarações *)
\par 
\par   \i0\cf1 TPicture = \b class\b0 ;
\par   TPictures = \b class\b0 ;
\par 
\par   \cf0\i (* Referências *)
\par 
\par   \i0\cf1 TRefGraphics = \b class of \b0 TGraphics;
\par 
\par   \cf0\i (* TVertex *)
\par 
\par   \i0\cf1 TVertex = \b record
\par     \b0 Pos: TD3DXVector3;
\par     Normal: TD3DXVector3;
\par     Tu, Tv: Single;
\par   \b end\b0 ;
\par   PVertex = \b array\b0 [\cf0 0\cf1 ..\cf0 0\cf1 ] \b of \b0 TVertex;
\par 
\par   \cf0\i (* TGraphics *)
\par 
\par   \i0\cf1 PGraphics = ^TGraphics;
\par   TGraphics = \b class
\par   private
\par     \b0 FD3D: IDirect3D8;
\par     FDevice: IDirect3DDevice8;
\par     FVertexBuffer: IDirect3DVertexBuffer8;
\par     FD3DDM: TD3DDisplayMode;
\par     FD3DPP: TD3DPresent_Parameters;
\par     FBackSurface: IDirect3DSurface8;
\par     FBpp: Integer;
\par     FOnInitialize: TNotifyEvent;
\par     FOnFinalize: TNotifyEvent;
\par   \b protected
\par     procedure \b0 DoInitialize; \b virtual\b0 ;
\par     \b procedure \b0 DoFinalize; \b virtual\b0 ;
\par   \b public
\par     constructor \b0 Create;
\par     \b destructor \b0 Destroy;
\par     \b function \b0 Run: Integer;
\par     \b procedure \b0 Clear;
\par     \b procedure \b0 BeginScene;
\par     \b procedure \b0 EndScene;
\par     \b procedure \b0 Flip;
\par     \b procedure \b0 Restore;
\par     \b property \b0 OnInitialize: TNotifyEvent \b read \b0 FOnInitialize \b write \b0 FOnInitialize;
\par     \b property \b0 OnFinalize: TNotifyEvent \b read \b0 FOnFinalize \b write \b0 FOnFinalize;
\par     \b property \b0 D3D: IDirect3D8 \b read \b0 FD3D \b write \b0 FD3D;
\par     \b property \b0 Device: IDirect3DDevice8 \b read \b0 FDevice \b write \b0 FDevice;
\par     \b property \b0 VertexBuffer: IDirect3DVertexBuffer8 \b read \b0 FVertexBuffer \b write \b0 FVertexBuffer;
\par     \b property \b0 BackBuffer: IDirect3DSurface8 \b read \b0 FBackSurface \b write \b0 FBackSurface;
\par     \b property \b0 Parameters: TD3DPresent_Parameters \b read \b0 FD3DPP \b write \b0 FD3DPP;
\par     \b property \b0 DisplayMode: TD3DDisplayMode \b read \b0 FD3DDM \b write \b0 FD3DDM;
\par     \b property \b0 Bpp: Integer \b read \b0 FBpp \b write \b0 FBpp;
\par   \b end\b0 ;
\par 
\par   \cf0\i (* T3DBrush *)
\par 
\par   \i0\cf1 P3DBrush = ^T3DBrush;
\par   T3DBrush = \b class
\par     \b0 Alpha: Byte;
\par     Color: TD3DColor;
\par   \b end\b0 ;
\par 
\par   \cf0\i (* T3DFont *)
\par 
\par   \i0\cf1 P3DFont = ^T3DFont;
\par   T3DFont = \b class
\par     \b0 Name: \b string\b0 ;
\par     Size: Integer;
\par     Color: TD3DColor;
\par     Font: HFONT;
\par   \b end\b0 ;
\par 
\par   \cf0\i (* TCanvas *)
\par 
\par   \i0\cf1 PCanvas = ^TCanvas;
\par   TCanvas = \b class
\par   private
\par     \b0 F3DBrush: T3DBrush;
\par     F3DFont: T3DFont;
\par     FDXSprite: ID3DXSprite;
\par     FDXFont: ID3DXFont;
\par     FOldFont: T3DFont;
\par   \b public
\par     constructor \b0 Create(Graphics: TGraphics);
\par     \b procedure \b0 TextOut(X, Y: Single; \b const \b0 Text: \b string\b0 );
\par     \b procedure \b0 CreateTextureFromSurface(Surface: IDirect3DSurface8; SrcRect: TRect;
\par       ColorKey: TD3DColor; \b var \b0 Texture: IDirect3DTexture8);
\par     \b procedure \b0 DrawTexture(X, Y: Single; Width, Height: Integer; \b const \b0 Texture: IDirect3DTexture8);
\par     \b procedure \b0 DrawEx(X, Y: Single; Source: TRect; Scale: TD3DXVector2; AxisRot: TD3DXVector2;
\par       Rotation: Single; Alpha: Byte; Color: TD3DColor; \b const \b0 Texture: IDirect3DTexture8);
\par     \b procedure \b0 DrawExP(X, Y: Single; Source: PRect; Scale: PD3DXVector2; AxisRot: PD3DXVector2;
\par       Rotation: Single; Alpha: Byte; Color: TD3DColor; \b const \b0 Texture: IDirect3DTexture8);
\par     \b procedure \b0 Draw(X, Y: Single; Picture: TPicture; Index: Integer);
\par     \b procedure \b0 DrawAlpha(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte);
\par     \b procedure \b0 DrawRotate(X, Y: Single; Picture: TPicture; Index: Integer; CenterX, CenterY: Single; Angle: Single);
\par     \b procedure \b0 DrawSub(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte);
\par     \b procedure \b0 DrawRotateAlpha(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte; CenterX, CenterY: Single; Angle: Single);
\par     \b procedure \b0 DrawRotateSub(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte; CenterX, CenterY: Single; Angle: Single);
\par     \b procedure \b0 SpriteBegin;
\par     \b procedure \b0 SpriteEnd;
\par     \b property \b0 Brush: T3DBrush \b read \b0 F3DBrush \b write \b0 F3DBrush;
\par     \b property \b0 Font: T3DFont \b read \b0 F3DFont \b write \b0 F3DFont;
\par     \b property \b0 Sprite: ID3DXSprite \b read \b0 FDXSprite \b write \b0 FDXSprite;
\par   \b end\b0 ;
\par 
\par   TImage = \b class
\par   public
\par     \b0 Image: IDirect3DTexture8;
\par   \b end\b0 ;
\par 
\par   TPicture = \b class\b0 (TCollectionItem)
\par   \b private
\par     \b0 FInfo: TD3DXImageInfo;
\par     FName: \b string\b0 [\cf0 255\cf1 ];
\par     FFileName: \b string\b0 [\cf0 255\cf1 ];
\par     FPatternWidth: Integer;
\par     FPatternHeight: Integer;
\par     FSkipWidth: Integer;
\par     FSkipHeight: Integer;
\par     FTransparent: Boolean;
\par     FTransparentColor: TD3DColor;
\par     FTextureList: TList;
\par     \b function \b0 GetName: \b string\b0 ;
\par     \b procedure \b0 SetName(Value: \b string\b0 );
\par     \b function \b0 GetWidth: Integer;
\par     \b function \b0 GetHeight: Integer;
\par     \b function \b0 GetItem(Index: Integer): TImage;
\par     \b function \b0 GetCount: Integer;
\par     \b function \b0 GetFileName: \b string\b0 ;
\par     \b procedure \b0 SetFileName(Value: \b string\b0 );
\par   \b public
\par     constructor \b0 Create(Collection: TCollection); \b override\b0 ;
\par     \b destructor \b0 Destroy;
\par     \b function \b0 LoadFromFile(\b const \b0 FilePicture: \b string\b0 ): Boolean;
\par     \b function \b0 SaveToFile(\b const \b0 FilePicture: \b string\b0 ): Boolean;
\par     \b property \b0 Info: TD3DXImageInfo \b read \b0 FInfo \b write \b0 FInfo;
\par     \b property \b0 Name: \b string read \b0 GetName \b write \b0 SetName;
\par     \b property \b0 PatternWidth: Integer \b read \b0 FPatternWidth \b write \b0 FPatternWidth;
\par     \b property \b0 PatternHeight: Integer \b read \b0 FPatternHeight \b write \b0 FPatternHeight;
\par     \b property \b0 SkipWidth: Integer \b read \b0 FSkipWidth \b write \b0 FSkipWidth;
\par     \b property \b0 SkipHeight: Integer \b read \b0 FSkipHeight \b write \b0 FSkipHeight;
\par     \b property \b0 Transparent: Boolean \b read \b0 FTransparent \b write \b0 FTransparent;
\par     \b property \b0 TransparentColor: TD3DColor \b read \b0 FTransparentColor \b write \b0 FTransparentColor;
\par     \b property \b0 FileName: \b string read \b0 GetFileName \b write \b0 SetFileName;
\par     \b property \b0 PatternTextures[\b Index\b0 : Integer]: TImage \b read \b0 GetItem;
\par     \b property \b0 Width: Integer \b read \b0 GetWidth;
\par     \b property \b0 Height: Integer \b read \b0 GetHeight;
\par     \b property \b0 PatternCount: Integer \b read \b0 GetCount;
\par   \b end\b0 ;
\par 
\par   TPictures = \b class\b0 (TCollection)
\par   \b private
\par     function \b0 IndexOf(Name: \b string\b0 ): TPicture;
\par     \b function \b0 GetItem(Index: Integer): TPicture;
\par   \b public
\par     function \b0 Add: TPicture;
\par     \b function \b0 AddEx(FileName: \b string\b0 ; Name: \b string\b0 ; PatternWidth, PatternHeight: Integer; ColorKey: Longint;
\par       SkipWidth: Integer = \cf0 0\cf1 ; SkipHeight: Integer = \cf0 0\cf1 ): TPicture;
\par     \b function \b0 Find(\b const \b0 Name: \b string\b0 ): TPicture;
\par     \b property \b0 Item[\b Index\b0 : Integer]: TPicture \b read \b0 GetItem;
\par   \b end\b0 ;
\par 
\par   THeaderPicture = \b record
\par     \b0 Name: \b string\b0 [\cf0 255\cf1 ];
\par     FilePicture: \b string\b0 [\cf0 255\cf1 ];
\par     PatternWidth: Integer;
\par     PatternHeight: Integer;
\par     SkipWidth: Integer;
\par     SkipHeight: Integer;
\par     TransparentColor: TD3DColor;
\par   \b end\b0 ;
\par 
\par   TButton = \b class\b0 (TControl)
\par   \b public
\par     \b0 Style: Integer;
\par     \b procedure \b0 DoMouseEnter; \b override\b0 ;
\par     \b procedure \b0 DoMouseLeave; \b override\b0 ;
\par     \b procedure \b0 DoDraw;
\par   \b end\b0 ;
\par 
\par \b const
\par   \b0 D3DFVFVERTEX = D3DFVF_XYZ \b or \b0 D3DFVF_NORMAL \b or \b0 D3DFVF_TEX1;
\par 
\par \b function \b0 Vertex(Pos: TD3DXVector3; Normal: TD3DXVector3; Tu, Tv: Single): TVertex;
\par \b function \b0 TextWidth(\b const \b0 Text: \b string\b0 ): Integer;
\par \b function \b0 TextHeight(\b const \b0 Text: \b string\b0 ): Integer;
\par \b function \b0 DrawButton(X, Y: Single; Width, Height, Style: Integer; \b const \b0 Text: \b string\b0 ): Boolean;
\par 
\par \b var
\par   \b0 Graphics: TGraphics;
\par   Canvas: TCanvas = \b nil\b0 ;
\par 
\par \b implementation
\par 
\par uses
\par   \b0 brForms;
\par 
\par \b function \b0 Vertex(Pos: TD3DXVector3; Normal: TD3DXVector3; Tu, Tv: Single): TVertex;
\par \b begin
\par   \b0 Result.Pos := Pos;
\par   Result.Normal := Normal;
\par   Result.tu := tu;
\par   Result.tv := tv;
\par \b end\b0 ;
\par 
\par \b function \b0 TextWidth(\b const \b0 Text: \b string\b0 ): Integer;
\par \b var
\par   \b0 Sz: TSize;
\par \b begin
\par   \b0 Windows.GetTextExtentPoint32(Window.Handle, PChar(Text), Length(Text), Sz);
\par   Result := Sz.cx;
\par \b end\b0 ;
\par 
\par \b function \b0 TextHeight(\b const \b0 Text: \b string\b0 ): Integer;
\par \b var
\par   \b0 Sz: TSize;
\par \b begin
\par   \b0 Windows.GetTextExtentPoint32(Window.Handle, PChar(Text), Length(Text), Sz);
\par   Result := Sz.cy;
\par \b end\b0 ;
\par 
\par \b function \b0 DrawButton(X, Y: Single; Width, Height, Style: Integer; \b const \b0 Text: \b string\b0 ): Boolean;
\par \b var
\par   \b0 S: TD3DXVector2;
\par \b begin
\par   \b0 Result := True;
\par 
\par   \b case \b0 Style \b of
\par     \b0\cf0 0\cf1 :
\par       \b begin
\par         \b0 S := D3DXVector2(Width, Height);
\par         Canvas.DrawExP(X, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 29\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width, \cf0 1\cf1 );
\par         Canvas.DrawExP(X, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 28\cf1 ].Image);
\par 
\par         S := D3DXVector2(\cf0 1\cf1 , Height);
\par         Canvas.DrawExP(X, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 28\cf1 ].Image);
\par         Canvas.DrawExP(X + Width, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width + \cf0 1\cf1 , \cf0 1\cf1 );
\par         Canvas.DrawExP(X, Y + Height, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par 
\par         S := D3DXVector2(\cf0 1\cf1 , Height - \cf0 2\cf1 );
\par         Canvas.DrawExP(X + Width - \cf0 1\cf1 , Y + \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width - \cf0 1\cf1 , \cf0 1\cf1 );
\par         Canvas.DrawExP(X + \cf0 1\cf1 , Y + Height - \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par 
\par       \cf0\i //  Canvas.TextOut(X + ((Width - TextWidth(Text)) div 2), Y + ((Height - TextHeight(Text)) div 2), Text);
\par       \i0\cf1\b end\b0 ;
\par     \cf0 1\cf1 :
\par       \b begin
\par         \b0 S := D3DXVector2(Width, Height);
\par         Canvas.DrawExP(X, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 29\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width - \cf0 2\cf1 , \cf0 1\cf1 );
\par         Canvas.DrawExP(X + \cf0 1\cf1 , Y + \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 28\cf1 ].Image);
\par 
\par         S := D3DXVector2(\cf0 1\cf1 , Height - \cf0 2\cf1 );
\par         Canvas.DrawExP(X + \cf0 1\cf1 , Y + \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 28\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width - \cf0 3\cf1 , \cf0 1\cf1 );
\par         Canvas.DrawExP(X + \cf0 2\cf1 , Y + Height - \cf0 2\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par 
\par         S := D3DXVector2(\cf0 1\cf1 , Height - \cf0 4\cf1 );
\par         Canvas.DrawExP(X + Width - \cf0 2\cf1 , Y + \cf0 2\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width, \cf0 1\cf1 );
\par         Canvas.DrawExP(X, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par         Canvas.DrawExP(X, Y + Height - \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par 
\par         S := D3DXVector2(\cf0 1\cf1 , Height);
\par         Canvas.DrawExP(X, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par         Canvas.DrawExP(X + Width, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width + \cf0 1\cf1 , \cf0 1\cf1 );
\par         Canvas.DrawExP(X, Y + Height, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par         S := D3DXVector2(\cf0 1\cf1 , Height);
\par         Canvas.DrawExP(X + Width - \cf0 1\cf1 , Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par 
\par       \cf0\i //  Canvas.TextOut(X + ((Width - TextWidth(Text)) div 2), Y + ((Height - TextHeight(Text)) div 2), Text);
\par       \i0\cf1\b end\b0 ;
\par     \cf0 2\cf1 :
\par       \b begin
\par         \b0 S := D3DXVector2(Width, Height);
\par         Canvas.DrawExP(X, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 29\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width, \cf0 1\cf1 );
\par         Canvas.DrawExP(X, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par 
\par         S := D3DXVector2(\cf0 1\cf1 , Height);
\par         Canvas.DrawExP(X, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par         Canvas.DrawExP(X + Width, Y, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width + \cf0 1\cf1 , \cf0 1\cf1 );
\par         Canvas.DrawExP(X, Y + Height, \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 0\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width - \cf0 2\cf1 , \cf0 1\cf1 );
\par         Canvas.DrawExP(X + \cf0 1\cf1 , Y + \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par         Canvas.DrawExP(X + \cf0 1\cf1 , Y + \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par 
\par         S := D3DXVector2(\cf0 1\cf1 , Height - \cf0 2\cf1 );
\par         Canvas.DrawExP(X + \cf0 1\cf1 , Y + \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par         Canvas.DrawExP(X + \cf0 1\cf1 , Y + \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par 
\par         S := D3DXVector2(Width - \cf0 1\cf1 , \cf0 1\cf1 );
\par         Canvas.DrawExP(X + \cf0 1\cf1 , Y + Height - \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par 
\par         S := D3DXVector2(\cf0 1\cf1 , Height - \cf0 2\cf1 );
\par         Canvas.DrawExP(X + Width - \cf0 1\cf1 , Y + \cf0 1\cf1 , \b nil\b0 , @S, \b nil\b0 , \cf0 0\cf1 , \cf0 255\cf1 , clWhite, PictureList.Item[\cf0 0\cf1 ].PatternTextures[\cf0 30\cf1 ].Image);
\par 
\par       \cf0\i //  Canvas.TextOut(X + 1 +((Width - TextWidth(Text)) div 2), Y + 1 + ((Height - TextHeight(Text)) div 2), Text);
\par       \i0\cf1\b end\b0 ;
\par   \b else
\par     \b0 Result := False;
\par   \b end\b0 ;
\par 
\par \b end\b0 ;
\par 
\par   \cf0\i (* TGraphics *)
\par 
\par \i0\cf1\b constructor \b0 TGraphics.Create;
\par \b begin
\par   if \b0 Assigned(Graphics) \b then
\par     raise \b0 ELogError.Create(Format(ERROR_EXISTS, [\cf0 'TGraphics'\cf1 ]))
\par   \b else
\par     \b0 SaveLog(Format(EVENT_CREATE, [\cf0 'TGraphics'\cf1 ]));
\par 
\par   Graphics := Self;
\par   FD3D := \b nil\b0 ;
\par   FDevice := \b nil\b0 ;
\par   FBackSurface := \b nil\b0 ;
\par   FBpp := \cf0 32\cf1 ;
\par \b end\b0 ;
\par 
\par \b destructor \b0 TGraphics.Destroy;
\par \b begin
\par   \b0 DoFinalize;
\par 
\par   \b if \b0 Assigned(FBackSurface) \b then
\par   begin
\par     \b0 FBackSurface._Release;
\par     FBackSurface := \b nil\b0 ;
\par   \b end\b0 ;
\par   \b if \b0 Assigned(FDevice) \b then
\par   begin
\par     \b0 FDevice._Release;
\par     FDevice := \b nil\b0 ;
\par   \b end\b0 ;
\par   \b if \b0 Assigned(FD3D) \b then
\par   begin
\par     \b0 FD3D._Release;
\par     FD3D := \b nil\b0 ;
\par   \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TGraphics.Run: Integer;
\par \b var
\par   \b0 Hr: HResult;
\par   MatProj, MatView: TD3DXMatrix;
\par   pVertices: ^PVertex;
\par   K: Integer;
\par \b begin
\par   \b0 Result := E_FAIL;
\par 
\par   SaveLog(Format(EVENT_TALK, [\cf0 'TGraphics.Run'\cf1 ]));
\par 
\par   FD3D := Direct3DCreate8(D3D_SDK_VERSION);
\par   \b if \b0 FD3D = \b nil then
\par     raise \b0 EError.Create(Format(ERROR_EXISTS, [\cf0 'IDirect3D8'\cf1 ]))
\par   \b else
\par     \b0 SaveLog(Format(EVENT_CREATE, [\cf0 'IDirect3D8'\cf1 ]));
\par 
\par   Fillchar(FD3DPP, SizeOf(FD3DPP), \cf0 0\cf1 );
\par 
\par   FD3DPP.Windowed := \b not \b0 Window.FullScreen;
\par   FD3DPP.hDeviceWindow := Window.Handle;
\par   FD3DPP.EnableAutoDepthStencil := False;
\par   FD3DPP.BackBufferCount := \cf0 1\cf1 ;
\par   FD3DPP.Flags := D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
\par 
\par   \b if \b0 Window.FullScreen \b then
\par   begin
\par     \b0 FD3DPP.BackBufferWidth := Window.Width;
\par     FD3DPP.BackBufferHeight := Window.Height;
\par     \b case \b0 FBpp \b of
\par       \b0\cf0 8\cf1 : FD3DPP.BackBufferFormat := D3DFMT_R3G3B2;
\par       \cf0 15\cf1 : FD3DPP.BackBufferFormat := D3DFMT_X1R5G5B5;
\par       \cf0 16\cf1 : FD3DPP.BackBufferFormat := D3DFMT_R5G6B5;
\par       \cf0 24\cf1 : FD3DPP.BackBufferFormat := D3DFMT_X8R8G8B8;
\par       \cf0 32\cf1 : FD3DPP.BackBufferFormat := D3DFMT_A8R8G8B8;
\par     \b else
\par       \b0 FD3DPP.BackBufferFormat := D3DFMT_A8R8G8B8;
\par     \b end\b0 ;
\par     FD3DPP.SwapEffect := D3DSWAPEFFECT_COPY;
\par     FD3DPP.MultiSampleType := D3DMULTISAMPLE_NONE;
\par     FD3DPP.EnableAutoDepthStencil := False;
\par     FD3DPP.AutoDepthStencilFormat := D3DFMT_D16;
\par     FD3DPP.FullScreen_RefreshRateInHz := D3DPRESENT_RATE_DEFAULT;
\par     FD3DPP.FullScreen_PresentationInterval := D3DPRESENT_INTERVAL_IMMEDIATE;
\par   \b end
\par   else
\par   begin
\par     if \b0 Failed(FD3D.GetAdapterDisplayMode(D3DADAPTER_DEFAULT, FD3DDM)) \b then
\par       raise \b0 EError.Create(Format(EVENT_ERROR, [\cf0 'TGraphics.Initialize'\cf1 ]));
\par 
\par     FD3DPP.BackBufferFormat := FD3DDM.Format;
\par     FD3DPP.SwapEffect := D3DSWAPEFFECT_DISCARD;
\par   \b end\b0 ;
\par 
\par   Hr := FD3D.CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, Window.Handle,
\par     D3DCREATE_HARDWARE_VERTEXPROCESSING, FD3DPP, FDevice);
\par   \b if \b0 Failed(hr) \b then
\par   begin
\par     \b0 Hr := FD3D.CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, Window.Handle,
\par       D3DCREATE_MIXED_VERTEXPROCESSING, FD3DPP, FDevice);
\par     \b if \b0 Failed(Hr) \b then
\par     begin
\par       \b0 Hr := FD3D.CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, Window.Handle,
\par         D3DCREATE_SOFTWARE_VERTEXPROCESSING, FD3DPP, FDevice);
\par       \b if \b0 FAILED(Hr) \b then
\par         \b0 Hr := FD3D.CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, Window.Handle,
\par           D3DCREATE_SOFTWARE_VERTEXPROCESSING, FD3DPP, FDevice);
\par       \b if \b0 Failed(Hr) \b then
\par         raise \b0 EError.Create(ERROR_CREATEDEVICE)
\par       \b else
\par         \b0 SaveLog(Format(EVENT_CREATE, [\cf0 'IDirect3DDevice8'\cf1 ]));
\par     \b end\b0 ;
\par   \b end\b0 ;
\par 
\par   D3DXMatrixIdentity(MatView);
\par   FDevice.SetTransform(D3DTS_VIEW, MatView);
\par 
\par   D3DXMatrixOrthoLH(MatProj, Window.Width, Window.Height, \cf0 0\cf1 , \cf0 1\cf1 );
\par   FDevice.SetTransform(D3DTS_PROJECTION, MatProj);
\par   FDevice.SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);
\par   FDevice.SetRenderState(D3DRS_LIGHTING, iFalse);
\par   FDevice.SetRenderState(D3DRS_ZENABLE, iFalse);
\par   FDevice.SetRenderState(D3DRS_ZWRITEENABLE, iFalse);
\par 
\par   \b if \b0 Failed(FDevice.CreateVertexBuffer(\cf0 4 \cf1 * Sizeof(TVertex), \cf0 0\cf1 , D3DFVFVERTEX,
\par     D3DPOOL_DEFAULT, FVertexBuffer)) \b then
\par     \b0 Exit;
\par 
\par   \b if \b0 FAILED(FVertexBuffer.Lock(\cf0 0\cf1 , \cf0 0\cf1 , PByte(pVertices), \cf0 0\cf1 )) \b then
\par     \b0 Exit;
\par 
\par   K := \cf0 1\cf1 ;
\par 
\par   pVertices[\cf0 0 \cf1 * K] := Vertex(D3DXVECTOR3(\cf0 0.0\cf1 , \cf0 0.0\cf1 , \cf0 0.0\cf1 ), D3DXVECTOR3(\cf0 0.0\cf1 , \cf0 0.0\cf1 , \cf0 1.0\cf1 ), \cf0 0.0\cf1 , \cf0 1.0\cf1 );
\par 
\par   pVertices[\cf0 1 \cf1 * K] := Vertex(D3DXVECTOR3(\cf0 0.0\cf1 , \cf0 1.0\cf1 , \cf0 0.0\cf1 ), D3DXVECTOR3(\cf0 0.0\cf1 , \cf0 0.0\cf1 , \cf0 1.0\cf1 ), \cf0 0.0\cf1 , \cf0 0.0\cf1 );
\par 
\par   pVertices[\cf0 2 \cf1 * K] := Vertex(D3DXVECTOR3(\cf0 1.0\cf1 , \cf0 0.0\cf1 , \cf0 0.0\cf1 ), D3DXVECTOR3(\cf0 0.0\cf1 , \cf0 0.0\cf1 , \cf0 1.0\cf1 ), \cf0 1.0\cf1 , \cf0 1.0\cf1 );
\par 
\par   pVertices[\cf0 3 \cf1 * K] := Vertex(D3DXVECTOR3(\cf0 1.0\cf1 , \cf0 1.0\cf1 , \cf0 0.0\cf1 ), D3DXVECTOR3(\cf0 0.0\cf1 , \cf0 0.0\cf1 , \cf0 1.0\cf1 ), \cf0 1.0\cf1 , \cf0 0.0\cf1 );
\par 
\par   FVertexBuffer.Unlock;
\par 
\par   FDevice.GetBackBuffer(\cf0 0\cf1 , D3DBACKBUFFER_TYPE_MONO, FBackSurface);
\par 
\par   Canvas := TCanvas.Create(Self);
\par 
\par   DoInitialize;
\par 
\par   Result := S_OK;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TGraphics.Clear;
\par \b begin
\par   \b0 FDevice.Clear(\cf0 0\cf1 , \b nil\b0 , D3DCLEAR_TARGET, Canvas.Brush.Color, \cf0 1.0\cf1 , \cf0 0\cf1 );
\par \b end\b0 ;
\par 
\par \b procedure \b0 TGraphics.BeginScene;
\par \b begin
\par   \b0 FDevice.BeginScene;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TGraphics.EndScene;
\par \b begin
\par   \b0 FDevice.EndScene;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TGraphics.Flip;
\par \b begin
\par   \b0 FDevice.Present(\b nil\b0 , \b nil\b0 , \cf0 0\cf1 , \b nil\b0 );
\par \b end\b0 ;
\par 
\par \b procedure \b0 TGraphics.Restore;
\par \b var
\par   \b0 MatProj, MatView: TD3DXMatrix;
\par \b begin
\par   \b0 D3DXMatrixIdentity(MatView);
\par   FDevice.SetTransform(D3DTS_VIEW, MatView);
\par 
\par   D3DXMatrixOrthoLH(MatProj, Window.Width, Window.Height, \cf0 0\cf1 , \cf0 1\cf1 );
\par \b end\b0 ;
\par 
\par \b procedure \b0 TGraphics.DoInitialize;
\par \b begin
\par   if \b0 Assigned(FOnInitialize) \b then \b0 FOnInitialize(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TGraphics.DoFinalize;
\par \b begin
\par   if \b0 Assigned(FOnFinalize) \b then \b0 FOnFinalize(Self);
\par \b end\b0 ;
\par 
\par   \cf0\i (* TCanvas *)
\par 
\par \i0\cf1\b constructor \b0 TCanvas.Create;
\par \b begin
\par   \b0 F3DFont := T3DFont.Create;
\par   F3DFont.Name := \cf0 'Arial'\cf1 ;
\par   F3DFont.Size := \cf0 20\cf1 ;
\par   F3DFont.Font := \cf0 0\cf1 ;
\par   F3DFont.Font := CreateFont(F3DFont.Size, \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 ,
\par     PROOF_QUALITY, \cf0 0\cf1 , PChar(F3DFont.Name));
\par   F3DFont.Color := clWhite;
\par 
\par   FOldFont := T3DFont.Create;
\par 
\par   F3DBrush := T3DBrush.Create;
\par   F3DBrush.Alpha := \cf0 255\cf1 ;
\par   F3DBrush.Color := clBlack;
\par 
\par   D3DXCreateSprite(Graphics.Device, FDXSprite);
\par 
\par   D3DXCreateFont(Graphics.Device, F3DFont.Font, FDXFont);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.TextOut(X, Y: Single; \b const \b0 Text: \b string\b0 );
\par \b var
\par   \b0 I: Integer;
\par   Rect: TRect;
\par \b begin
\par   \b0 I := Length(Text);
\par 
\par   SetRect(Rect, Trunc(X), Trunc(Y), Trunc(X) + (F3DFont.Size * I), Trunc(Y) + F3DFont.Size);
\par 
\par   \b if \b0 (F3DFont.Name <> FOldFont.Name) \b or
\par     \b0 (F3DFont.Size <> FOldFont.Size) \b or
\par     \b0 (F3DFont.Color <> FOldFont.Color) \b then
\par   begin
\par     \b0 F3DFont.Font := CreateFont(F3DFont.Size, \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 ,
\par       PROOF_QUALITY, \cf0 0\cf1 , PChar(F3DFont.Name));
\par     D3DXCreateFont(Graphics.Device, F3DFont.Font, FDXFont);
\par     FOldFont := Font;
\par   \b end\b0 ;
\par 
\par   FDXFont._Begin;
\par 
\par   FDXFont.DrawTextA(PChar(Text), Length(Text), Rect, DT_LEFT, (\cf0 255 \cf1\b shl \b0\cf0 24\cf1 ) + F3DFont.Color);
\par 
\par   FDXFont._End;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.CreateTextureFromSurface(Surface: IDirect3DSurface8; SrcRect: TRect;
\par   ColorKey: TD3DColor; \b var \b0 Texture: IDirect3DTexture8);
\par \b var
\par   \b0 TexSurface: IDirect3DSurface8;
\par \b begin
\par   \b0 D3DXCreateTexture(Graphics.Device, SrcRect.Right - SrcRect.Left,
\par     SrcRect.Bottom - SrcRect.Top, \cf0 0\cf1 , \cf0 0\cf1 , \cf0 0\cf1 , D3DPOOL_DEFAULT, Texture);
\par 
\par   Texture.GetSurfaceLevel(\cf0 0\cf1 , TexSurface);
\par 
\par   D3DXLoadSurfaceFromSurface(TexSurface, \b nil\b0 , \b nil\b0 , Surface, \b nil\b0 , @SrcRect, D3DX_FILTER_NONE, ColorKey);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.Draw(X, Y: Single; Picture: TPicture; Index: Integer);
\par \b begin
\par   \b0 DrawAlpha(X, Y, Picture, Index, \cf0 255\cf1 );
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.DrawAlpha(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte);
\par \b var
\par   \b0 Pos: TD3DXVector2;
\par \b begin
\par   \b0 Pos := D3DXVector2(X, Y);
\par   FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, \b nil\b0 , \b nil\b0 , \b nil\b0 , \cf0 0\cf1 , @Pos, (Alpha \b shl \b0\cf0 24\cf1 ) + \cf0 $FFFFFF\cf1 );
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.DrawRotate(X, Y: Single; Picture: TPicture; Index: Integer; CenterX, CenterY: Single; Angle: Single);
\par \b var
\par   \b0 Pos: TD3DXVector2;
\par   Center: TD3DXVector2;
\par \b begin
\par   \b0 Pos := D3DXVector2(X, Y);
\par   Center := D3DXVector2(CenterX, CenterY);
\par   FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, \b nil\b0 , \b nil\b0 , @Center, Angle, @Pos, \cf0 $FFFFFFFF\cf1 );
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.DrawSub(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte);
\par \b var
\par   \b0 Pos: TD3DXVector2;
\par \b begin
\par   \b0 Pos := D3DXVector2(X, Y);
\par   FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, \b nil\b0 , \b nil\b0 , \b nil\b0 , \cf0 0\cf1 , @Pos, (Alpha \b shl \b0\cf0 24\cf1 ) + clBlack);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.DrawRotateAlpha(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte; CenterX, CenterY: Single; Angle: Single);
\par \b var
\par   \b0 Pos: TD3DXVector2;
\par   Center: TD3DXVector2;
\par \b begin
\par   \b0 Pos := D3DXVector2(X, Y);
\par   Center := D3DXVector2(CenterX, CenterY);
\par   FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, \b nil\b0 , \b nil\b0 , @Center, Angle, @Pos, (Alpha \b shl \b0\cf0 24\cf1 ) + \cf0 $FFFFFF\cf1 );
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.DrawRotateSub(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte; CenterX, CenterY: Single; Angle: Single);
\par \b var
\par   \b0 Pos: TD3DXVector2;
\par   Center: TD3DXVector2;
\par \b begin
\par   \b0 Pos := D3DXVector2(X, Y);
\par   Center := D3DXVector2(CenterX, CenterY);
\par   FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, \b nil\b0 , \b nil\b0 , @Center, Angle, @Pos, (Alpha \b shl \b0\cf0 24\cf1 ) + clBlack);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.DrawTexture(X, Y: Single; Width, Height: Integer; \b const \b0 Texture: IDirect3DTexture8);
\par \b var
\par   \b0 MatWorld, MatRotation, MatTranslation, MatScale: TD3DXMatrix;
\par   FX, FY: Single;
\par \b begin
\par   \b0 D3DXMatrixIdentity(MatTranslation);
\par 
\par   D3DXMatrixScaling(MatScale, Width, Height, \cf0 1.0\cf1 );
\par   D3DXMatrixMultiply(MatTranslation, MatTranslation, MatScale);
\par 
\par   D3DXMatrixRotationZ(MatRotation, \cf0 0.0\cf1 );
\par   D3DXMatrixMultiply(MatWorld, MatTranslation, MatRotation);
\par 
\par 
\par   FX := -(Window.Width \b div \b0\cf0 2\cf1 ) + X;
\par   FY := (Window.Height \b div \b0\cf0 2\cf1 ) - Height - Y;
\par 
\par   MatWorld._41 := FX;
\par   MatWorld._42 := FY;
\par 
\par   Graphics.Device.SetTransform(D3DTS_WORLD, MatWorld);
\par   Graphics.Device.SetTexture(\cf0 0\cf1 , Texture);
\par   Graphics.Device.SetStreamSource(\cf0 0\cf1 , Graphics.VertexBuffer, SizeOf(TVertex));
\par   Graphics.Device.SetVertexShader(D3DFVFVERTEX);
\par   Graphics.Device.DrawPrimitive(D3DPT_TRIANGLESTRIP, \cf0 0\cf1 , \cf0 2\cf1 );
\par 
\par   Graphics.Device.SetTexture(\cf0 0\cf1 , \b nil\b0 );
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.DrawEx(X, Y: Single; Source: TRect; Scale: TD3DXVector2; AxisRot: TD3DXVector2;
\par   Rotation: Single; Alpha: Byte; Color: TD3DColor; \b const \b0 Texture: IDirect3DTexture8);
\par \b var
\par   \b0 Pos: TD3DXVector2;
\par \b begin
\par   \b0 Pos := D3DXVector2(X, Y);
\par   FDXSprite.Draw(Texture, @Source, @Scale, @AxisRot, Rotation, @Pos, (Alpha \b shl \b0\cf0 24\cf1 ) + Color);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.DrawExP(X, Y: Single; Source: PRect; Scale: PD3DXVector2; AxisRot: PD3DXVector2;
\par   Rotation: Single; Alpha: Byte; Color: TD3DColor; \b const \b0 Texture: IDirect3DTexture8);
\par \b var
\par   \b0 Pos: TD3DXVector2;
\par \b begin
\par   \b0 Pos := D3DXVector2(X, Y);
\par   \b if \b0 Failed(FDXSprite.Draw(Texture, Source, Scale, AxisRot, Rotation, @Pos, (Alpha \b shl \b0\cf0 24\cf1 ) + Color)) \b then
\par     \b0 MessageBox(\cf0 0\cf1 , \cf0 '0'\cf1 , \cf0 '0'\cf1 , MB_OK); ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.SpriteBegin;
\par \b begin
\par   \b0 FDXSprite._Begin;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TCanvas.SpriteEnd;
\par \b begin
\par   \b0 FDXSprite._End;
\par \b end\b0 ;
\par 
\par \b constructor \b0 TPicture.Create;
\par \b begin
\par   inherited \b0 Create(Collection);
\par   FPatternWidth := \cf0 0\cf1 ;
\par   FPatternHeight := \cf0 0\cf1 ;
\par   FSkipWidth := \cf0 0\cf1 ;
\par   FSkipHeight := \cf0 0\cf1 ;
\par   FTransparent := True;
\par   FTransparentColor := clFuchsia;
\par \b end\b0 ;
\par 
\par \b destructor \b0 TPicture.Destroy;
\par \b begin
\par   \b0 FTextureList.Free;
\par \b end\b0 ;
\par 
\par \b function \b0 TPicture.GetItem(Index: Integer): TImage;
\par \b begin
\par   \b0 Result := TImage(FTextureList.Items[Index]);
\par \b end\b0 ;
\par 
\par \b function \b0 TPicture.GetCount: Integer;
\par \b begin
\par   \b0 Result := FTextureList.Count - \cf0 1\cf1 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TPicture.GetName: \b string\b0 ;
\par \b begin
\par   \b0 Result := FName;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TPicture.SetName(Value: \b string\b0 );
\par \b begin
\par   \b0 FName := Value;
\par \b end\b0 ;
\par 
\par \b function \b0 TPicture.GetWidth: Integer;
\par \b begin
\par   \b0 Result := FPatternWidth;
\par 
\par   \b if \b0 (Result <= \cf0 0\cf1 ) \b then
\par     \b0 Result := FInfo.Width;
\par \b end\b0 ;
\par 
\par \b function \b0 TPicture.GetHeight: Integer;
\par \b begin
\par   \b0 Result := FPatternHeight;
\par 
\par   \b if \b0 (Result <= \cf0 0\cf1 ) \b then
\par     \b0 Result := FInfo.Height;
\par \b end\b0 ;
\par 
\par \b function \b0 TPicture.GetFileName: \b string\b0 ;
\par \b begin
\par   \b0 Result := FileName;
\par \b end\b0 ;
\par 
\par \b function \b0 D3DXLoadSurfaceFromFile(_filename: pChar;
\par   _format: TD3DFormat): IDirect3DSurface8;
\par 
\par \b var \b0 _r: TRect;
\par   _imginfo: TD3DXImageInfo;
\par 
\par \b begin
\par   \b0 Result := \b nil\b0 ;
\par 
\par   \cf0\i // Create a 16 bit dummy surface.
\par   \i0\cf1\b if \b0 (failed(Graphics.Device.CreateImageSurface(\cf0 4\cf1 , \cf0 4\cf1 , D3DFMT_R5G6B5,
\par     Result))) \b or \b0 (Result = \b nil\b0 ) \b then \b0 exit;
\par 
\par   \cf0\i // Load file into dummy surface.
\par   \i0\cf1 _r.Left := \cf0 0\cf1 ;
\par   _r.Top := \cf0 0\cf1 ;
\par   _r.Right := \cf0 3\cf1 ;
\par   _r.Bottom := \cf0 3\cf1 ;
\par   \b if \b0 (failed(D3DXLoadSurfaceFromFileA(Result, \b nil\b0 , @_r, _filename, \b nil\b0 ,
\par     D3DX_FILTER_NONE, \cf0 0\cf1 , @_imginfo)))
\par     \b then \b0 Result := \b nil\b0 ;
\par 
\par   \cf0\i // All right ?
\par   \i0\cf1\b if \b0 Result <> \b nil then
\par   begin
\par    \b0\cf0\i // MessageBox(0, '0', '0', MB_OK);
\par       // Destroy dummy surface and create a new one with the image
\par       // dimensions.
\par     \i0\cf1 Result := \b nil\b0 ;
\par 
\par       \cf0\i // Create the surface.
\par     \i0\cf1\b if \b0 _format = \cf0 0 \cf1\b then \b0 _format := _imginfo.Format;
\par     \b with \b0 _imginfo \b do
\par       if \b0 (failed(Graphics.Device.CreateImageSurface(Width, Height, _format,
\par         Result))) \b or \b0 (Result = \b nil\b0 ) \b then \b0 exit;
\par 
\par       \cf0\i // Load file into the surface.
\par     \i0\cf1\b if \b0 (failed(D3DXLoadSurfaceFromFileA(Result, \b nil\b0 , \b nil\b0 , _filename,
\par       \b nil\b0 , D3DX_FILTER_NONE, \cf0 0\cf1 , \b nil\b0 )))
\par       \b then \b0 Result := \b nil\b0 ;
\par   \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TPicture.SetFileName(Value: \b string\b0 );
\par \b var
\par   \b0 Texture: IDirect3DTexture8;
\par   Surface: IDirect3DSurface8;
\par   FRect: TRect;
\par   I, J: Integer;
\par   L, M: Integer;
\par 
\par   \b function \b0 AddTexture(\b const \b0 SrcRect: TRect): IDirect3DTexture8;
\par   \b begin
\par     \b0 Canvas.CreateTextureFromSurface(Surface, SrcRect, FTransparentColor, Result);
\par     FTextureList.Add(TImage.Create);
\par     TImage(FTextureList[FTextureList.Count - \cf0 1\cf1 ]).Image := Result;
\par   \b end\b0 ;
\par 
\par \b begin
\par   \b0 FTextureList := TList.Create;
\par 
\par   FFileName := Value;
\par 
\par   \b if \b0 Failed(D3DXGetImageInfoFromFile(PChar(Value), FInfo)) \b then
\par     raise \b0 EError.Create(Format(ERROR_NOTFOUND, [Value]))
\par   \b else
\par     \b0 SaveLog(Format(EVENT_FOUND, [Value]));
\par 
\par   Surface := D3DXLoadSurfaceFromFile(PChar(Value), \cf0 0\cf1 );
\par 
\par   \b if \b0 (GetWidth = FInfo.Width) \b and \b0 (GetHeight = FInfo.Height) \b then
\par   begin
\par     \b0 SetRect(FRect, \cf0 0\cf1 , \cf0 0\cf1 , FInfo.Width, FInfo.Height);
\par     \b if \b0 AddTexture(FRect) = \b nil then
\par       \b0 Exit;
\par   \b end
\par   else
\par   begin
\par     \b0 L := \cf0 0\cf1 ;
\par     \b if \b0 FPatternWidth <> \cf0 0 \cf1\b then
\par       \b0 L := (FInfo.Width + FSkipWidth) \b div \b0 (FPatternWidth + FSkipWidth);
\par 
\par     M := \cf0 0\cf1 ;
\par     \b if \b0 FPatternHeight <> \cf0 0 \cf1\b then
\par       \b0 M := (FInfo.Height + FSkipHeight) \b div \b0 (FPatternHeight + FSkipHeight);
\par 
\par     \b for \b0 J := \cf0 0 \cf1\b to \b0 M - \cf0 1 \cf1\b do
\par       for \b0 I := \cf0 0 \cf1\b to \b0 L - \cf0 1 \cf1\b do
\par       begin
\par         \b0 SetRect(FRect, I * (FPatternWidth + FSkipWidth), J * (FPatternHeight + FSkipHeight),
\par           (I * (FPatternWidth + FSkipWidth)) + FPatternWidth, (J * (FPatternHeight + FSkipHeight)) + FPatternHeight);
\par 
\par         \b if \b0 AddTexture(FRect) = \b nil then
\par           \b0 Exit;
\par       \b end\b0 ;
\par   \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TPicture.LoadFromFile(\b const \b0 FilePicture: \b string\b0 ): Boolean;
\par \b var
\par   \b0 FileHeader: \b file of \b0 THeaderPicture;
\par   HeaderPicture: THeaderPicture;
\par \b begin
\par   if \b0 Length(FilePicture) = \cf0 0 \cf1\b then
\par     \b0 Exit;
\par 
\par   AssignFile(FileHeader, FilePicture);
\par \cf0\i \{$I-\}
\par   \i0\cf1 Reset(FileHeader);
\par \cf0\i \{$I+\}
\par   \i0\cf1\b if \b0 IORESULT <> \cf0 0 \cf1\b then
\par   begin
\par     \b0 CloseFile(FileHeader);
\par     Exit;
\par   \b end\b0 ;
\par   Read(FileHeader, HeaderPicture);
\par   CloseFile(FileHeader);
\par 
\par   FName := HeaderPicture.Name;
\par   FFileName := HeaderPicture.FilePicture;
\par   FPatternWidth := HeaderPicture.PatternWidth;
\par   FPatternHeight := HeaderPicture.PatternHeight;
\par   FSkipWidth := HeaderPicture.SkipWidth;
\par   FSkipHeight := HeaderPicture.SkipHeight;
\par   FTransparentColor := HeaderPicture.TransparentColor;
\par 
\par   SetFileName(FFileName);
\par \b end\b0 ;
\par 
\par \b function \b0 TPicture.SaveToFile(\b const \b0 FilePicture: \b string\b0 ): Boolean;
\par \b var
\par   \b0 FileHeader: \b file of \b0 THeaderPicture;
\par   HeaderPicture: THeaderPicture;
\par \b begin
\par   if \b0 Length(FilePicture) = \cf0 0 \cf1\b then
\par     \b0 Exit;
\par 
\par   AssignFile(FileHeader, FilePicture);
\par   \b if \b0 FileExists(FilePicture) \b then
\par     \b0 Reset(FileHeader)
\par   \b else
\par     \b0 Rewrite(FileHeader);
\par 
\par   HeaderPicture.Name := FName;
\par   HeaderPicture.FilePicture := FFileName;
\par   HeaderPicture.PatternWidth := FPatternWidth;
\par   HeaderPicture.PatternHeight := FPatternHeight;
\par   HeaderPicture.SkipWidth := FSkipWidth;
\par   HeaderPicture.SkipHeight := FSkipHeight;
\par   HeaderPicture.TransparentColor := FTransparentColor;
\par 
\par   Write(FileHeader, HeaderPicture);
\par   CloseFile(FileHeader);
\par \b end\b0 ;
\par 
\par \b function \b0 TPictures.IndexOf(Name: \b string\b0 ): TPicture;
\par \b var
\par   \b0 I: Integer;
\par \b begin
\par   for \b0 I := \cf0 0 \cf1\b to \b0 Count - \cf0 1 \cf1\b do
\par   begin
\par     if \b0 GetItem(I).Name = Name \b then
\par     begin
\par       \b0 Result := GetItem(I);
\par       Exit;
\par     \b end\b0 ;
\par   \b end\b0 ;
\par 
\par   Result := \b nil\b0 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TPictures.GetItem(Index: Integer): TPicture;
\par \b begin
\par   \b0 Result := \b inherited \b0 Items[Index] \b as \b0 TPicture;
\par \b end\b0 ;
\par 
\par \b function \b0 TPictures.Add: TPicture;
\par \b begin
\par   \b0 Result := \b inherited \b0 Add \b as \b0 TPicture;
\par \b end\b0 ;
\par 
\par \b function \b0 TPictures.AddEx(FileName: \b string\b0 ; Name: \b string\b0 ; PatternWidth, PatternHeight: Integer;
\par   ColorKey: Longint; SkipWidth: Integer = \cf0 0\cf1 ; SkipHeight: Integer = \cf0 0\cf1 ): TPicture;
\par \b begin
\par   \b0 Result := \b inherited \b0 Add \b as \b0 TPicture;
\par 
\par   Result.Name := Name;
\par   Result.PatternWidth := PatternWidth;
\par   Result.PatternHeight := PatternHeight;
\par   Result.SkipWidth := SkipWidth;
\par   Result.SkipHeight := SkipHeight;
\par   Result.TransparentColor := ColorKey;
\par 
\par   Result.FileName := FileName;
\par \b end\b0 ;
\par 
\par \b function \b0 TPictures.Find(\b const \b0 Name: \b string\b0 ): TPicture;
\par \b begin
\par   \b0 Result := IndexOf(Name);
\par   \b if \b0 Result = \b nil then
\par     raise \b0 EError.Create(Format(ERROR_NOTFOUND, [Name]));
\par \b end\b0 ;
\par 
\par \b procedure \b0 TButton.DoMouseEnter;
\par \b begin
\par   \b0 Style := \cf0 1\cf1 ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TButton.DoMouseLeave;
\par \b begin
\par   \b0 Style := \cf0 0\cf1 ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TButton.DoDraw;
\par \b begin
\par   if \b0 (Clicked) \b and \b0 (MouseIn) \b then
\par     \b0 DrawButton(Left, Top, Width, Height, \cf0 2\cf1 , \cf0 'Teste'\cf1 )
\par   \b else
\par     \b0 DrawButton(Left, Top, Width, Height, Style, \cf0 'Teste'\cf1 )
\par \b end\b0 ;
\par 
\par \b end\b0 .
\par 
\par }
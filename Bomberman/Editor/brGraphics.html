<html>
<head>
<title>brGraphics.html</title>
</head>
<!-- Generated by SynEdit HTML exporter -->
<body text="#000000" bgcolor="#FFFFFF">
<pre>
<code><font  size=3 face="Courier New"><font color="#000080"><i>(*******************************************************)
(*                                                     *)
(*       Engine Paulovich DirectX                      *)
(*       Win32-DirectX API Unit                        *)
(*                                                     *)
(*       Copyright (c) 2003-2004, Ivan Paulovich       *)
(*                                                     *)
(*       iskatrek@hotmail.com  uin#89160524            *)
(*                                                     *)
(*       Unit: brGraphics                              *)
(*                                                     *)
(*******************************************************)

</i></font><b>unit </b>brGraphics;

<b>interface

uses
  </b>Windows, SysUtils, Classes, brControls,
  D3DX8, <font color="#000080"><i>{$IFDEF DXG_COMPAT}</i></font>DirectXGraphics<font color="#000080"><i>{$ELSE}</i></font>Direct3D8<font color="#000080"><i>{$ENDIF}</i></font>;

<b>type

  </b><font color="#000080"><i>(* Pre-Declara&ccedil;&otilde;es *)

  </i></font>TPicture = <b>class</b>;
  TPictures = <b>class</b>;

  <font color="#000080"><i>(* Refer&ecirc;ncias *)

  </i></font>TRefGraphics = <b>class of </b>TGraphics;

  <font color="#000080"><i>(* TVertex *)

  </i></font>TVertex = <b>record
    </b>Pos: TD3DXVector3;
    Normal: TD3DXVector3;
    Tu, Tv: Single;
  <b>end</b>;
  PVertex = <b>array</b>[<font color="#000080">0</font>..<font color="#000080">0</font>] <b>of </b>TVertex;

  <font color="#000080"><i>(* TGraphics *)

  </i></font>PGraphics = ^TGraphics;
  TGraphics = <b>class
  private
    </b>FD3D: IDirect3D8;
    FDevice: IDirect3DDevice8;
    FVertexBuffer: IDirect3DVertexBuffer8;
    FD3DDM: TD3DDisplayMode;
    FD3DPP: TD3DPresent_Parameters;
    FBackSurface: IDirect3DSurface8;
    FBpp: Integer;
    FOnInitialize: TNotifyEvent;
    FOnFinalize: TNotifyEvent;
  <b>protected
    procedure </b>DoInitialize; <b>virtual</b>;
    <b>procedure </b>DoFinalize; <b>virtual</b>;
  <b>public
    constructor </b>Create;
    <b>destructor </b>Destroy;
    <b>function </b>Run: Integer;
    <b>procedure </b>Clear;
    <b>procedure </b>BeginScene;
    <b>procedure </b>EndScene;
    <b>procedure </b>Flip;
    <b>procedure </b>Restore;
    <b>property </b>OnInitialize: TNotifyEvent <b>read </b>FOnInitialize <b>write </b>FOnInitialize;
    <b>property </b>OnFinalize: TNotifyEvent <b>read </b>FOnFinalize <b>write </b>FOnFinalize;
    <b>property </b>D3D: IDirect3D8 <b>read </b>FD3D <b>write </b>FD3D;
    <b>property </b>Device: IDirect3DDevice8 <b>read </b>FDevice <b>write </b>FDevice;
    <b>property </b>VertexBuffer: IDirect3DVertexBuffer8 <b>read </b>FVertexBuffer <b>write </b>FVertexBuffer;
    <b>property </b>BackBuffer: IDirect3DSurface8 <b>read </b>FBackSurface <b>write </b>FBackSurface;
    <b>property </b>Parameters: TD3DPresent_Parameters <b>read </b>FD3DPP <b>write </b>FD3DPP;
    <b>property </b>DisplayMode: TD3DDisplayMode <b>read </b>FD3DDM <b>write </b>FD3DDM;
    <b>property </b>Bpp: Integer <b>read </b>FBpp <b>write </b>FBpp;
  <b>end</b>;

  <font color="#000080"><i>(* T3DBrush *)

  </i></font>P3DBrush = ^T3DBrush;
  T3DBrush = <b>class
    </b>Alpha: Byte;
    Color: TD3DColor;
  <b>end</b>;

  <font color="#000080"><i>(* T3DFont *)

  </i></font>P3DFont = ^T3DFont;
  T3DFont = <b>class
    </b>Name: <b>string</b>;
    Size: Integer;
    Color: TD3DColor;
    Font: HFONT;
  <b>end</b>;

  <font color="#000080"><i>(* TCanvas *)

  </i></font>PCanvas = ^TCanvas;
  TCanvas = <b>class
  private
    </b>F3DBrush: T3DBrush;
    F3DFont: T3DFont;
    FDXSprite: ID3DXSprite;
    FDXFont: ID3DXFont;
    FOldFont: T3DFont;
  <b>public
    constructor </b>Create(Graphics: TGraphics);
    <b>procedure </b>TextOut(X, Y: Single; <b>const </b>Text: <b>string</b>);
    <b>procedure </b>CreateTextureFromSurface(Surface: IDirect3DSurface8; SrcRect: TRect;
      ColorKey: TD3DColor; <b>var </b>Texture: IDirect3DTexture8);
    <b>procedure </b>DrawTexture(X, Y: Single; Width, Height: Integer; <b>const </b>Texture: IDirect3DTexture8);
    <b>procedure </b>DrawEx(X, Y: Single; Source: TRect; Scale: TD3DXVector2; AxisRot: TD3DXVector2;
      Rotation: Single; Alpha: Byte; Color: TD3DColor; <b>const </b>Texture: IDirect3DTexture8);
    <b>procedure </b>DrawExP(X, Y: Single; Source: PRect; Scale: PD3DXVector2; AxisRot: PD3DXVector2;
      Rotation: Single; Alpha: Byte; Color: TD3DColor; <b>const </b>Texture: IDirect3DTexture8);
    <b>procedure </b>Draw(X, Y: Single; Picture: TPicture; Index: Integer);
    <b>procedure </b>DrawAlpha(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte);
    <b>procedure </b>DrawRotate(X, Y: Single; Picture: TPicture; Index: Integer; CenterX, CenterY: Single; Angle: Single);
    <b>procedure </b>DrawSub(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte);
    <b>procedure </b>DrawRotateAlpha(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte; CenterX, CenterY: Single; Angle: Single);
    <b>procedure </b>DrawRotateSub(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte; CenterX, CenterY: Single; Angle: Single);
    <b>procedure </b>SpriteBegin;
    <b>procedure </b>SpriteEnd;
    <b>property </b>Brush: T3DBrush <b>read </b>F3DBrush <b>write </b>F3DBrush;
    <b>property </b>Font: T3DFont <b>read </b>F3DFont <b>write </b>F3DFont;
    <b>property </b>Sprite: ID3DXSprite <b>read </b>FDXSprite <b>write </b>FDXSprite;
  <b>end</b>;

  TImage = <b>class
  public
    </b>Image: IDirect3DTexture8;
  <b>end</b>;

  TPicture = <b>class</b>(TCollectionItem)
  <b>private
    </b>FInfo: TD3DXImageInfo;
    FName: <b>string</b>[<font color="#000080">255</font>];
    FFileName: <b>string</b>[<font color="#000080">255</font>];
    FPatternWidth: Integer;
    FPatternHeight: Integer;
    FSkipWidth: Integer;
    FSkipHeight: Integer;
    FTransparent: Boolean;
    FTransparentColor: TD3DColor;
    FTextureList: TList;
    <b>function </b>GetName: <b>string</b>;
    <b>procedure </b>SetName(Value: <b>string</b>);
    <b>function </b>GetWidth: Integer;
    <b>function </b>GetHeight: Integer;
    <b>function </b>GetItem(Index: Integer): TImage;
    <b>function </b>GetCount: Integer;
    <b>function </b>GetFileName: <b>string</b>;
    <b>procedure </b>SetFileName(Value: <b>string</b>);
  <b>public
    constructor </b>Create(Collection: TCollection); <b>override</b>;
    <b>destructor </b>Destroy;
    <b>function </b>LoadFromFile(<b>const </b>FilePicture: <b>string</b>): Boolean;
    <b>function </b>SaveToFile(<b>const </b>FilePicture: <b>string</b>): Boolean;
    <b>property </b>Info: TD3DXImageInfo <b>read </b>FInfo <b>write </b>FInfo;
    <b>property </b>Name: <b>string read </b>GetName <b>write </b>SetName;
    <b>property </b>PatternWidth: Integer <b>read </b>FPatternWidth <b>write </b>FPatternWidth;
    <b>property </b>PatternHeight: Integer <b>read </b>FPatternHeight <b>write </b>FPatternHeight;
    <b>property </b>SkipWidth: Integer <b>read </b>FSkipWidth <b>write </b>FSkipWidth;
    <b>property </b>SkipHeight: Integer <b>read </b>FSkipHeight <b>write </b>FSkipHeight;
    <b>property </b>Transparent: Boolean <b>read </b>FTransparent <b>write </b>FTransparent;
    <b>property </b>TransparentColor: TD3DColor <b>read </b>FTransparentColor <b>write </b>FTransparentColor;
    <b>property </b>FileName: <b>string read </b>GetFileName <b>write </b>SetFileName;
    <b>property </b>PatternTextures[<b>Index</b>: Integer]: TImage <b>read </b>GetItem;
    <b>property </b>Width: Integer <b>read </b>GetWidth;
    <b>property </b>Height: Integer <b>read </b>GetHeight;
    <b>property </b>PatternCount: Integer <b>read </b>GetCount;
  <b>end</b>;

  TPictures = <b>class</b>(TCollection)
  <b>private
    function </b>IndexOf(Name: <b>string</b>): TPicture;
    <b>function </b>GetItem(Index: Integer): TPicture;
  <b>public
    function </b>Add: TPicture;
    <b>function </b>AddEx(FileName: <b>string</b>; Name: <b>string</b>; PatternWidth, PatternHeight: Integer; ColorKey: Longint;
      SkipWidth: Integer = <font color="#000080">0</font>; SkipHeight: Integer = <font color="#000080">0</font>): TPicture;
    <b>function </b>Find(<b>const </b>Name: <b>string</b>): TPicture;
    <b>property </b>Item[<b>Index</b>: Integer]: TPicture <b>read </b>GetItem;
  <b>end</b>;

  THeaderPicture = <b>record
    </b>Name: <b>string</b>[<font color="#000080">255</font>];
    FilePicture: <b>string</b>[<font color="#000080">255</font>];
    PatternWidth: Integer;
    PatternHeight: Integer;
    SkipWidth: Integer;
    SkipHeight: Integer;
    TransparentColor: TD3DColor;
  <b>end</b>;

  TButton = <b>class</b>(TControl)
  <b>public
    </b>Style: Integer;
    <b>procedure </b>DoMouseEnter; <b>override</b>;
    <b>procedure </b>DoMouseLeave; <b>override</b>;
    <b>procedure </b>DoDraw;
  <b>end</b>;

<b>const
  </b>D3DFVFVERTEX = D3DFVF_XYZ <b>or </b>D3DFVF_NORMAL <b>or </b>D3DFVF_TEX1;

<b>function </b>Vertex(Pos: TD3DXVector3; Normal: TD3DXVector3; Tu, Tv: Single): TVertex;
<b>function </b>TextWidth(<b>const </b>Text: <b>string</b>): Integer;
<b>function </b>TextHeight(<b>const </b>Text: <b>string</b>): Integer;
<b>function </b>DrawButton(X, Y: Single; Width, Height, Style: Integer; <b>const </b>Text: <b>string</b>): Boolean;

<b>var
  </b>Graphics: TGraphics;
  Canvas: TCanvas = <b>nil</b>;

<b>implementation

uses
  </b>brForms;

<b>function </b>Vertex(Pos: TD3DXVector3; Normal: TD3DXVector3; Tu, Tv: Single): TVertex;
<b>begin
  </b>Result.Pos := Pos;
  Result.Normal := Normal;
  Result.tu := tu;
  Result.tv := tv;
<b>end</b>;

<b>function </b>TextWidth(<b>const </b>Text: <b>string</b>): Integer;
<b>var
  </b>Sz: TSize;
<b>begin
  </b>Windows.GetTextExtentPoint32(Window.Handle, PChar(Text), Length(Text), Sz);
  Result := Sz.cx;
<b>end</b>;

<b>function </b>TextHeight(<b>const </b>Text: <b>string</b>): Integer;
<b>var
  </b>Sz: TSize;
<b>begin
  </b>Windows.GetTextExtentPoint32(Window.Handle, PChar(Text), Length(Text), Sz);
  Result := Sz.cy;
<b>end</b>;

<b>function </b>DrawButton(X, Y: Single; Width, Height, Style: Integer; <b>const </b>Text: <b>string</b>): Boolean;
<b>var
  </b>S: TD3DXVector2;
<b>begin
  </b>Result := True;

  <b>case </b>Style <b>of
    </b><font color="#000080">0</font>:
      <b>begin
        </b>S := D3DXVector2(Width, Height);
        Canvas.DrawExP(X, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">29</font>].Image);

        S := D3DXVector2(Width, <font color="#000080">1</font>);
        Canvas.DrawExP(X, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">28</font>].Image);

        S := D3DXVector2(<font color="#000080">1</font>, Height);
        Canvas.DrawExP(X, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">28</font>].Image);
        Canvas.DrawExP(X + Width, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);

        S := D3DXVector2(Width + <font color="#000080">1</font>, <font color="#000080">1</font>);
        Canvas.DrawExP(X, Y + Height, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);

        S := D3DXVector2(<font color="#000080">1</font>, Height - <font color="#000080">2</font>);
        Canvas.DrawExP(X + Width - <font color="#000080">1</font>, Y + <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);

        S := D3DXVector2(Width - <font color="#000080">1</font>, <font color="#000080">1</font>);
        Canvas.DrawExP(X + <font color="#000080">1</font>, Y + Height - <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);

      <font color="#000080"><i>//  Canvas.TextOut(X + ((Width - TextWidth(Text)) div 2), Y + ((Height - TextHeight(Text)) div 2), Text);
      </i></font><b>end</b>;
    <font color="#000080">1</font>:
      <b>begin
        </b>S := D3DXVector2(Width, Height);
        Canvas.DrawExP(X, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">29</font>].Image);

        S := D3DXVector2(Width - <font color="#000080">2</font>, <font color="#000080">1</font>);
        Canvas.DrawExP(X + <font color="#000080">1</font>, Y + <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">28</font>].Image);

        S := D3DXVector2(<font color="#000080">1</font>, Height - <font color="#000080">2</font>);
        Canvas.DrawExP(X + <font color="#000080">1</font>, Y + <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">28</font>].Image);

        S := D3DXVector2(Width - <font color="#000080">3</font>, <font color="#000080">1</font>);
        Canvas.DrawExP(X + <font color="#000080">2</font>, Y + Height - <font color="#000080">2</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);

        S := D3DXVector2(<font color="#000080">1</font>, Height - <font color="#000080">4</font>);
        Canvas.DrawExP(X + Width - <font color="#000080">2</font>, Y + <font color="#000080">2</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);

        S := D3DXVector2(Width, <font color="#000080">1</font>);
        Canvas.DrawExP(X, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);
        Canvas.DrawExP(X, Y + Height - <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);

        S := D3DXVector2(<font color="#000080">1</font>, Height);
        Canvas.DrawExP(X, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);
        Canvas.DrawExP(X + Width, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);

        S := D3DXVector2(Width + <font color="#000080">1</font>, <font color="#000080">1</font>);
        Canvas.DrawExP(X, Y + Height, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);
        S := D3DXVector2(<font color="#000080">1</font>, Height);
        Canvas.DrawExP(X + Width - <font color="#000080">1</font>, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);

      <font color="#000080"><i>//  Canvas.TextOut(X + ((Width - TextWidth(Text)) div 2), Y + ((Height - TextHeight(Text)) div 2), Text);
      </i></font><b>end</b>;
    <font color="#000080">2</font>:
      <b>begin
        </b>S := D3DXVector2(Width, Height);
        Canvas.DrawExP(X, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">29</font>].Image);

        S := D3DXVector2(Width, <font color="#000080">1</font>);
        Canvas.DrawExP(X, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);

        S := D3DXVector2(<font color="#000080">1</font>, Height);
        Canvas.DrawExP(X, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);
        Canvas.DrawExP(X + Width, Y, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);

        S := D3DXVector2(Width + <font color="#000080">1</font>, <font color="#000080">1</font>);
        Canvas.DrawExP(X, Y + Height, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">0</font>].Image);

        S := D3DXVector2(Width - <font color="#000080">2</font>, <font color="#000080">1</font>);
        Canvas.DrawExP(X + <font color="#000080">1</font>, Y + <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);
        Canvas.DrawExP(X + <font color="#000080">1</font>, Y + <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);

        S := D3DXVector2(<font color="#000080">1</font>, Height - <font color="#000080">2</font>);
        Canvas.DrawExP(X + <font color="#000080">1</font>, Y + <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);
        Canvas.DrawExP(X + <font color="#000080">1</font>, Y + <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);

        S := D3DXVector2(Width - <font color="#000080">1</font>, <font color="#000080">1</font>);
        Canvas.DrawExP(X + <font color="#000080">1</font>, Y + Height - <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);

        S := D3DXVector2(<font color="#000080">1</font>, Height - <font color="#000080">2</font>);
        Canvas.DrawExP(X + Width - <font color="#000080">1</font>, Y + <font color="#000080">1</font>, <b>nil</b>, @S, <b>nil</b>, <font color="#000080">0</font>, <font color="#000080">255</font>, clWhite, PictureList.Item[<font color="#000080">0</font>].PatternTextures[<font color="#000080">30</font>].Image);

      <font color="#000080"><i>//  Canvas.TextOut(X + 1 +((Width - TextWidth(Text)) div 2), Y + 1 + ((Height - TextHeight(Text)) div 2), Text);
      </i></font><b>end</b>;
  <b>else
    </b>Result := False;
  <b>end</b>;

<b>end</b>;

  <font color="#000080"><i>(* TGraphics *)

</i></font><b>constructor </b>TGraphics.Create;
<b>begin
  if </b>Assigned(Graphics) <b>then
    raise </b>ELogError.Create(Format(ERROR_EXISTS, [<font color="#000080">'TGraphics'</font>]))
  <b>else
    </b>SaveLog(Format(EVENT_CREATE, [<font color="#000080">'TGraphics'</font>]));

  Graphics := Self;
  FD3D := <b>nil</b>;
  FDevice := <b>nil</b>;
  FBackSurface := <b>nil</b>;
  FBpp := <font color="#000080">32</font>;
<b>end</b>;

<b>destructor </b>TGraphics.Destroy;
<b>begin
  </b>DoFinalize;

  <b>if </b>Assigned(FBackSurface) <b>then
  begin
    </b>FBackSurface._Release;
    FBackSurface := <b>nil</b>;
  <b>end</b>;
  <b>if </b>Assigned(FDevice) <b>then
  begin
    </b>FDevice._Release;
    FDevice := <b>nil</b>;
  <b>end</b>;
  <b>if </b>Assigned(FD3D) <b>then
  begin
    </b>FD3D._Release;
    FD3D := <b>nil</b>;
  <b>end</b>;
<b>end</b>;

<b>function </b>TGraphics.Run: Integer;
<b>var
  </b>Hr: HResult;
  MatProj, MatView: TD3DXMatrix;
  pVertices: ^PVertex;
  K: Integer;
<b>begin
  </b>Result := E_FAIL;

  SaveLog(Format(EVENT_TALK, [<font color="#000080">'TGraphics.Run'</font>]));

  FD3D := Direct3DCreate8(D3D_SDK_VERSION);
  <b>if </b>FD3D = <b>nil then
    raise </b>EError.Create(Format(ERROR_EXISTS, [<font color="#000080">'IDirect3D8'</font>]))
  <b>else
    </b>SaveLog(Format(EVENT_CREATE, [<font color="#000080">'IDirect3D8'</font>]));

  Fillchar(FD3DPP, SizeOf(FD3DPP), <font color="#000080">0</font>);

  FD3DPP.Windowed := <b>not </b>Window.FullScreen;
  FD3DPP.hDeviceWindow := Window.Handle;
  FD3DPP.EnableAutoDepthStencil := False;
  FD3DPP.BackBufferCount := <font color="#000080">1</font>;
  FD3DPP.Flags := D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

  <b>if </b>Window.FullScreen <b>then
  begin
    </b>FD3DPP.BackBufferWidth := Window.Width;
    FD3DPP.BackBufferHeight := Window.Height;
    <b>case </b>FBpp <b>of
      </b><font color="#000080">8</font>: FD3DPP.BackBufferFormat := D3DFMT_R3G3B2;
      <font color="#000080">15</font>: FD3DPP.BackBufferFormat := D3DFMT_X1R5G5B5;
      <font color="#000080">16</font>: FD3DPP.BackBufferFormat := D3DFMT_R5G6B5;
      <font color="#000080">24</font>: FD3DPP.BackBufferFormat := D3DFMT_X8R8G8B8;
      <font color="#000080">32</font>: FD3DPP.BackBufferFormat := D3DFMT_A8R8G8B8;
    <b>else
      </b>FD3DPP.BackBufferFormat := D3DFMT_A8R8G8B8;
    <b>end</b>;
    FD3DPP.SwapEffect := D3DSWAPEFFECT_COPY;
    FD3DPP.MultiSampleType := D3DMULTISAMPLE_NONE;
    FD3DPP.EnableAutoDepthStencil := False;
    FD3DPP.AutoDepthStencilFormat := D3DFMT_D16;
    FD3DPP.FullScreen_RefreshRateInHz := D3DPRESENT_RATE_DEFAULT;
    FD3DPP.FullScreen_PresentationInterval := D3DPRESENT_INTERVAL_IMMEDIATE;
  <b>end
  else
  begin
    if </b>Failed(FD3D.GetAdapterDisplayMode(D3DADAPTER_DEFAULT, FD3DDM)) <b>then
      raise </b>EError.Create(Format(EVENT_ERROR, [<font color="#000080">'TGraphics.Initialize'</font>]));

    FD3DPP.BackBufferFormat := FD3DDM.Format;
    FD3DPP.SwapEffect := D3DSWAPEFFECT_DISCARD;
  <b>end</b>;

  Hr := FD3D.CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, Window.Handle,
    D3DCREATE_HARDWARE_VERTEXPROCESSING, FD3DPP, FDevice);
  <b>if </b>Failed(hr) <b>then
  begin
    </b>Hr := FD3D.CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, Window.Handle,
      D3DCREATE_MIXED_VERTEXPROCESSING, FD3DPP, FDevice);
    <b>if </b>Failed(Hr) <b>then
    begin
      </b>Hr := FD3D.CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, Window.Handle,
        D3DCREATE_SOFTWARE_VERTEXPROCESSING, FD3DPP, FDevice);
      <b>if </b>FAILED(Hr) <b>then
        </b>Hr := FD3D.CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, Window.Handle,
          D3DCREATE_SOFTWARE_VERTEXPROCESSING, FD3DPP, FDevice);
      <b>if </b>Failed(Hr) <b>then
        raise </b>EError.Create(ERROR_CREATEDEVICE)
      <b>else
        </b>SaveLog(Format(EVENT_CREATE, [<font color="#000080">'IDirect3DDevice8'</font>]));
    <b>end</b>;
  <b>end</b>;

  D3DXMatrixIdentity(MatView);
  FDevice.SetTransform(D3DTS_VIEW, MatView);

  D3DXMatrixOrthoLH(MatProj, Window.Width, Window.Height, <font color="#000080">0</font>, <font color="#000080">1</font>);
  FDevice.SetTransform(D3DTS_PROJECTION, MatProj);
  FDevice.SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);
  FDevice.SetRenderState(D3DRS_LIGHTING, iFalse);
  FDevice.SetRenderState(D3DRS_ZENABLE, iFalse);
  FDevice.SetRenderState(D3DRS_ZWRITEENABLE, iFalse);

  <b>if </b>Failed(FDevice.CreateVertexBuffer(<font color="#000080">4 </font>* Sizeof(TVertex), <font color="#000080">0</font>, D3DFVFVERTEX,
    D3DPOOL_DEFAULT, FVertexBuffer)) <b>then
    </b>Exit;

  <b>if </b>FAILED(FVertexBuffer.Lock(<font color="#000080">0</font>, <font color="#000080">0</font>, PByte(pVertices), <font color="#000080">0</font>)) <b>then
    </b>Exit;

  K := <font color="#000080">1</font>;

  pVertices[<font color="#000080">0 </font>* K] := Vertex(D3DXVECTOR3(<font color="#000080">0.0</font>, <font color="#000080">0.0</font>, <font color="#000080">0.0</font>), D3DXVECTOR3(<font color="#000080">0.0</font>, <font color="#000080">0.0</font>, <font color="#000080">1.0</font>), <font color="#000080">0.0</font>, <font color="#000080">1.0</font>);

  pVertices[<font color="#000080">1 </font>* K] := Vertex(D3DXVECTOR3(<font color="#000080">0.0</font>, <font color="#000080">1.0</font>, <font color="#000080">0.0</font>), D3DXVECTOR3(<font color="#000080">0.0</font>, <font color="#000080">0.0</font>, <font color="#000080">1.0</font>), <font color="#000080">0.0</font>, <font color="#000080">0.0</font>);

  pVertices[<font color="#000080">2 </font>* K] := Vertex(D3DXVECTOR3(<font color="#000080">1.0</font>, <font color="#000080">0.0</font>, <font color="#000080">0.0</font>), D3DXVECTOR3(<font color="#000080">0.0</font>, <font color="#000080">0.0</font>, <font color="#000080">1.0</font>), <font color="#000080">1.0</font>, <font color="#000080">1.0</font>);

  pVertices[<font color="#000080">3 </font>* K] := Vertex(D3DXVECTOR3(<font color="#000080">1.0</font>, <font color="#000080">1.0</font>, <font color="#000080">0.0</font>), D3DXVECTOR3(<font color="#000080">0.0</font>, <font color="#000080">0.0</font>, <font color="#000080">1.0</font>), <font color="#000080">1.0</font>, <font color="#000080">0.0</font>);

  FVertexBuffer.Unlock;

  FDevice.GetBackBuffer(<font color="#000080">0</font>, D3DBACKBUFFER_TYPE_MONO, FBackSurface);

  Canvas := TCanvas.Create(Self);

  DoInitialize;

  Result := S_OK;
<b>end</b>;

<b>procedure </b>TGraphics.Clear;
<b>begin
  </b>FDevice.Clear(<font color="#000080">0</font>, <b>nil</b>, D3DCLEAR_TARGET, Canvas.Brush.Color, <font color="#000080">1.0</font>, <font color="#000080">0</font>);
<b>end</b>;

<b>procedure </b>TGraphics.BeginScene;
<b>begin
  </b>FDevice.BeginScene;
<b>end</b>;

<b>procedure </b>TGraphics.EndScene;
<b>begin
  </b>FDevice.EndScene;
<b>end</b>;

<b>procedure </b>TGraphics.Flip;
<b>begin
  </b>FDevice.Present(<b>nil</b>, <b>nil</b>, <font color="#000080">0</font>, <b>nil</b>);
<b>end</b>;

<b>procedure </b>TGraphics.Restore;
<b>var
  </b>MatProj, MatView: TD3DXMatrix;
<b>begin
  </b>D3DXMatrixIdentity(MatView);
  FDevice.SetTransform(D3DTS_VIEW, MatView);

  D3DXMatrixOrthoLH(MatProj, Window.Width, Window.Height, <font color="#000080">0</font>, <font color="#000080">1</font>);
<b>end</b>;

<b>procedure </b>TGraphics.DoInitialize;
<b>begin
  if </b>Assigned(FOnInitialize) <b>then </b>FOnInitialize(Self);
<b>end</b>;

<b>procedure </b>TGraphics.DoFinalize;
<b>begin
  if </b>Assigned(FOnFinalize) <b>then </b>FOnFinalize(Self);
<b>end</b>;

  <font color="#000080"><i>(* TCanvas *)

</i></font><b>constructor </b>TCanvas.Create;
<b>begin
  </b>F3DFont := T3DFont.Create;
  F3DFont.Name := <font color="#000080">'Arial'</font>;
  F3DFont.Size := <font color="#000080">20</font>;
  F3DFont.Font := <font color="#000080">0</font>;
  F3DFont.Font := CreateFont(F3DFont.Size, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>,
    PROOF_QUALITY, <font color="#000080">0</font>, PChar(F3DFont.Name));
  F3DFont.Color := clWhite;

  FOldFont := T3DFont.Create;

  F3DBrush := T3DBrush.Create;
  F3DBrush.Alpha := <font color="#000080">255</font>;
  F3DBrush.Color := clBlack;

  D3DXCreateSprite(Graphics.Device, FDXSprite);

  D3DXCreateFont(Graphics.Device, F3DFont.Font, FDXFont);
<b>end</b>;

<b>procedure </b>TCanvas.TextOut(X, Y: Single; <b>const </b>Text: <b>string</b>);
<b>var
  </b>I: Integer;
  Rect: TRect;
<b>begin
  </b>I := Length(Text);

  SetRect(Rect, Trunc(X), Trunc(Y), Trunc(X) + (F3DFont.Size * I), Trunc(Y) + F3DFont.Size);

  <b>if </b>(F3DFont.Name &lt;&gt; FOldFont.Name) <b>or
    </b>(F3DFont.Size &lt;&gt; FOldFont.Size) <b>or
    </b>(F3DFont.Color &lt;&gt; FOldFont.Color) <b>then
  begin
    </b>F3DFont.Font := CreateFont(F3DFont.Size, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>,
      PROOF_QUALITY, <font color="#000080">0</font>, PChar(F3DFont.Name));
    D3DXCreateFont(Graphics.Device, F3DFont.Font, FDXFont);
    FOldFont := Font;
  <b>end</b>;

  FDXFont._Begin;

  FDXFont.DrawTextA(PChar(Text), Length(Text), Rect, DT_LEFT, (<font color="#000080">255 </font><b>shl </b><font color="#000080">24</font>) + F3DFont.Color);

  FDXFont._End;
<b>end</b>;

<b>procedure </b>TCanvas.CreateTextureFromSurface(Surface: IDirect3DSurface8; SrcRect: TRect;
  ColorKey: TD3DColor; <b>var </b>Texture: IDirect3DTexture8);
<b>var
  </b>TexSurface: IDirect3DSurface8;
<b>begin
  </b>D3DXCreateTexture(Graphics.Device, SrcRect.Right - SrcRect.Left,
    SrcRect.Bottom - SrcRect.Top, <font color="#000080">0</font>, <font color="#000080">0</font>, <font color="#000080">0</font>, D3DPOOL_DEFAULT, Texture);

  Texture.GetSurfaceLevel(<font color="#000080">0</font>, TexSurface);

  D3DXLoadSurfaceFromSurface(TexSurface, <b>nil</b>, <b>nil</b>, Surface, <b>nil</b>, @SrcRect, D3DX_FILTER_NONE, ColorKey);
<b>end</b>;

<b>procedure </b>TCanvas.Draw(X, Y: Single; Picture: TPicture; Index: Integer);
<b>begin
  </b>DrawAlpha(X, Y, Picture, Index, <font color="#000080">255</font>);
<b>end</b>;

<b>procedure </b>TCanvas.DrawAlpha(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte);
<b>var
  </b>Pos: TD3DXVector2;
<b>begin
  </b>Pos := D3DXVector2(X, Y);
  FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, <b>nil</b>, <b>nil</b>, <b>nil</b>, <font color="#000080">0</font>, @Pos, (Alpha <b>shl </b><font color="#000080">24</font>) + <font color="#000080">$FFFFFF</font>);
<b>end</b>;

<b>procedure </b>TCanvas.DrawRotate(X, Y: Single; Picture: TPicture; Index: Integer; CenterX, CenterY: Single; Angle: Single);
<b>var
  </b>Pos: TD3DXVector2;
  Center: TD3DXVector2;
<b>begin
  </b>Pos := D3DXVector2(X, Y);
  Center := D3DXVector2(CenterX, CenterY);
  FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, <b>nil</b>, <b>nil</b>, @Center, Angle, @Pos, <font color="#000080">$FFFFFFFF</font>);
<b>end</b>;

<b>procedure </b>TCanvas.DrawSub(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte);
<b>var
  </b>Pos: TD3DXVector2;
<b>begin
  </b>Pos := D3DXVector2(X, Y);
  FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, <b>nil</b>, <b>nil</b>, <b>nil</b>, <font color="#000080">0</font>, @Pos, (Alpha <b>shl </b><font color="#000080">24</font>) + clBlack);
<b>end</b>;

<b>procedure </b>TCanvas.DrawRotateAlpha(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte; CenterX, CenterY: Single; Angle: Single);
<b>var
  </b>Pos: TD3DXVector2;
  Center: TD3DXVector2;
<b>begin
  </b>Pos := D3DXVector2(X, Y);
  Center := D3DXVector2(CenterX, CenterY);
  FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, <b>nil</b>, <b>nil</b>, @Center, Angle, @Pos, (Alpha <b>shl </b><font color="#000080">24</font>) + <font color="#000080">$FFFFFF</font>);
<b>end</b>;

<b>procedure </b>TCanvas.DrawRotateSub(X, Y: Single; Picture: TPicture; Index: Integer; Alpha: Byte; CenterX, CenterY: Single; Angle: Single);
<b>var
  </b>Pos: TD3DXVector2;
  Center: TD3DXVector2;
<b>begin
  </b>Pos := D3DXVector2(X, Y);
  Center := D3DXVector2(CenterX, CenterY);
  FDXSprite.Draw(TImage(Picture.PatternTextures[Index]).Image, <b>nil</b>, <b>nil</b>, @Center, Angle, @Pos, (Alpha <b>shl </b><font color="#000080">24</font>) + clBlack);
<b>end</b>;

<b>procedure </b>TCanvas.DrawTexture(X, Y: Single; Width, Height: Integer; <b>const </b>Texture: IDirect3DTexture8);
<b>var
  </b>MatWorld, MatRotation, MatTranslation, MatScale: TD3DXMatrix;
  FX, FY: Single;
<b>begin
  </b>D3DXMatrixIdentity(MatTranslation);

  D3DXMatrixScaling(MatScale, Width, Height, <font color="#000080">1.0</font>);
  D3DXMatrixMultiply(MatTranslation, MatTranslation, MatScale);

  D3DXMatrixRotationZ(MatRotation, <font color="#000080">0.0</font>);
  D3DXMatrixMultiply(MatWorld, MatTranslation, MatRotation);


  FX := -(Window.Width <b>div </b><font color="#000080">2</font>) + X;
  FY := (Window.Height <b>div </b><font color="#000080">2</font>) - Height - Y;

  MatWorld._41 := FX;
  MatWorld._42 := FY;

  Graphics.Device.SetTransform(D3DTS_WORLD, MatWorld);
  Graphics.Device.SetTexture(<font color="#000080">0</font>, Texture);
  Graphics.Device.SetStreamSource(<font color="#000080">0</font>, Graphics.VertexBuffer, SizeOf(TVertex));
  Graphics.Device.SetVertexShader(D3DFVFVERTEX);
  Graphics.Device.DrawPrimitive(D3DPT_TRIANGLESTRIP, <font color="#000080">0</font>, <font color="#000080">2</font>);

  Graphics.Device.SetTexture(<font color="#000080">0</font>, <b>nil</b>);
<b>end</b>;

<b>procedure </b>TCanvas.DrawEx(X, Y: Single; Source: TRect; Scale: TD3DXVector2; AxisRot: TD3DXVector2;
  Rotation: Single; Alpha: Byte; Color: TD3DColor; <b>const </b>Texture: IDirect3DTexture8);
<b>var
  </b>Pos: TD3DXVector2;
<b>begin
  </b>Pos := D3DXVector2(X, Y);
  FDXSprite.Draw(Texture, @Source, @Scale, @AxisRot, Rotation, @Pos, (Alpha <b>shl </b><font color="#000080">24</font>) + Color);
<b>end</b>;

<b>procedure </b>TCanvas.DrawExP(X, Y: Single; Source: PRect; Scale: PD3DXVector2; AxisRot: PD3DXVector2;
  Rotation: Single; Alpha: Byte; Color: TD3DColor; <b>const </b>Texture: IDirect3DTexture8);
<b>var
  </b>Pos: TD3DXVector2;
<b>begin
  </b>Pos := D3DXVector2(X, Y);
  <b>if </b>Failed(FDXSprite.Draw(Texture, Source, Scale, AxisRot, Rotation, @Pos, (Alpha <b>shl </b><font color="#000080">24</font>) + Color)) <b>then
    </b>MessageBox(<font color="#000080">0</font>, <font color="#000080">'0'</font>, <font color="#000080">'0'</font>, MB_OK); ;
<b>end</b>;

<b>procedure </b>TCanvas.SpriteBegin;
<b>begin
  </b>FDXSprite._Begin;
<b>end</b>;

<b>procedure </b>TCanvas.SpriteEnd;
<b>begin
  </b>FDXSprite._End;
<b>end</b>;

<b>constructor </b>TPicture.Create;
<b>begin
  inherited </b>Create(Collection);
  FPatternWidth := <font color="#000080">0</font>;
  FPatternHeight := <font color="#000080">0</font>;
  FSkipWidth := <font color="#000080">0</font>;
  FSkipHeight := <font color="#000080">0</font>;
  FTransparent := True;
  FTransparentColor := clFuchsia;
<b>end</b>;

<b>destructor </b>TPicture.Destroy;
<b>begin
  </b>FTextureList.Free;
<b>end</b>;

<b>function </b>TPicture.GetItem(Index: Integer): TImage;
<b>begin
  </b>Result := TImage(FTextureList.Items[Index]);
<b>end</b>;

<b>function </b>TPicture.GetCount: Integer;
<b>begin
  </b>Result := FTextureList.Count - <font color="#000080">1</font>;
<b>end</b>;

<b>function </b>TPicture.GetName: <b>string</b>;
<b>begin
  </b>Result := FName;
<b>end</b>;

<b>procedure </b>TPicture.SetName(Value: <b>string</b>);
<b>begin
  </b>FName := Value;
<b>end</b>;

<b>function </b>TPicture.GetWidth: Integer;
<b>begin
  </b>Result := FPatternWidth;

  <b>if </b>(Result &lt;= <font color="#000080">0</font>) <b>then
    </b>Result := FInfo.Width;
<b>end</b>;

<b>function </b>TPicture.GetHeight: Integer;
<b>begin
  </b>Result := FPatternHeight;

  <b>if </b>(Result &lt;= <font color="#000080">0</font>) <b>then
    </b>Result := FInfo.Height;
<b>end</b>;

<b>function </b>TPicture.GetFileName: <b>string</b>;
<b>begin
  </b>Result := FileName;
<b>end</b>;

<b>function </b>D3DXLoadSurfaceFromFile(_filename: pChar;
  _format: TD3DFormat): IDirect3DSurface8;

<b>var </b>_r: TRect;
  _imginfo: TD3DXImageInfo;

<b>begin
  </b>Result := <b>nil</b>;

  <font color="#000080"><i>// Create a 16 bit dummy surface.
  </i></font><b>if </b>(failed(Graphics.Device.CreateImageSurface(<font color="#000080">4</font>, <font color="#000080">4</font>, D3DFMT_R5G6B5,
    Result))) <b>or </b>(Result = <b>nil</b>) <b>then </b>exit;

  <font color="#000080"><i>// Load file into dummy surface.
  </i></font>_r.Left := <font color="#000080">0</font>;
  _r.Top := <font color="#000080">0</font>;
  _r.Right := <font color="#000080">3</font>;
  _r.Bottom := <font color="#000080">3</font>;
  <b>if </b>(failed(D3DXLoadSurfaceFromFileA(Result, <b>nil</b>, @_r, _filename, <b>nil</b>,
    D3DX_FILTER_NONE, <font color="#000080">0</font>, @_imginfo)))
    <b>then </b>Result := <b>nil</b>;

  <font color="#000080"><i>// All right ?
  </i></font><b>if </b>Result &lt;&gt; <b>nil then
  begin
   </b><font color="#000080"><i>// MessageBox(0, '0', '0', MB_OK);
      // Destroy dummy surface and create a new one with the image
      // dimensions.
    </i></font>Result := <b>nil</b>;

      <font color="#000080"><i>// Create the surface.
    </i></font><b>if </b>_format = <font color="#000080">0 </font><b>then </b>_format := _imginfo.Format;
    <b>with </b>_imginfo <b>do
      if </b>(failed(Graphics.Device.CreateImageSurface(Width, Height, _format,
        Result))) <b>or </b>(Result = <b>nil</b>) <b>then </b>exit;

      <font color="#000080"><i>// Load file into the surface.
    </i></font><b>if </b>(failed(D3DXLoadSurfaceFromFileA(Result, <b>nil</b>, <b>nil</b>, _filename,
      <b>nil</b>, D3DX_FILTER_NONE, <font color="#000080">0</font>, <b>nil</b>)))
      <b>then </b>Result := <b>nil</b>;
  <b>end</b>;
<b>end</b>;

<b>procedure </b>TPicture.SetFileName(Value: <b>string</b>);
<b>var
  </b>Texture: IDirect3DTexture8;
  Surface: IDirect3DSurface8;
  FRect: TRect;
  I, J: Integer;
  L, M: Integer;

  <b>function </b>AddTexture(<b>const </b>SrcRect: TRect): IDirect3DTexture8;
  <b>begin
    </b>Canvas.CreateTextureFromSurface(Surface, SrcRect, FTransparentColor, Result);
    FTextureList.Add(TImage.Create);
    TImage(FTextureList[FTextureList.Count - <font color="#000080">1</font>]).Image := Result;
  <b>end</b>;

<b>begin
  </b>FTextureList := TList.Create;

  FFileName := Value;

  <b>if </b>Failed(D3DXGetImageInfoFromFile(PChar(Value), FInfo)) <b>then
    raise </b>EError.Create(Format(ERROR_NOTFOUND, [Value]))
  <b>else
    </b>SaveLog(Format(EVENT_FOUND, [Value]));

  Surface := D3DXLoadSurfaceFromFile(PChar(Value), <font color="#000080">0</font>);

  <b>if </b>(GetWidth = FInfo.Width) <b>and </b>(GetHeight = FInfo.Height) <b>then
  begin
    </b>SetRect(FRect, <font color="#000080">0</font>, <font color="#000080">0</font>, FInfo.Width, FInfo.Height);
    <b>if </b>AddTexture(FRect) = <b>nil then
      </b>Exit;
  <b>end
  else
  begin
    </b>L := <font color="#000080">0</font>;
    <b>if </b>FPatternWidth &lt;&gt; <font color="#000080">0 </font><b>then
      </b>L := (FInfo.Width + FSkipWidth) <b>div </b>(FPatternWidth + FSkipWidth);

    M := <font color="#000080">0</font>;
    <b>if </b>FPatternHeight &lt;&gt; <font color="#000080">0 </font><b>then
      </b>M := (FInfo.Height + FSkipHeight) <b>div </b>(FPatternHeight + FSkipHeight);

    <b>for </b>J := <font color="#000080">0 </font><b>to </b>M - <font color="#000080">1 </font><b>do
      for </b>I := <font color="#000080">0 </font><b>to </b>L - <font color="#000080">1 </font><b>do
      begin
        </b>SetRect(FRect, I * (FPatternWidth + FSkipWidth), J * (FPatternHeight + FSkipHeight),
          (I * (FPatternWidth + FSkipWidth)) + FPatternWidth, (J * (FPatternHeight + FSkipHeight)) + FPatternHeight);

        <b>if </b>AddTexture(FRect) = <b>nil then
          </b>Exit;
      <b>end</b>;
  <b>end</b>;
<b>end</b>;

<b>function </b>TPicture.LoadFromFile(<b>const </b>FilePicture: <b>string</b>): Boolean;
<b>var
  </b>FileHeader: <b>file of </b>THeaderPicture;
  HeaderPicture: THeaderPicture;
<b>begin
  if </b>Length(FilePicture) = <font color="#000080">0 </font><b>then
    </b>Exit;

  AssignFile(FileHeader, FilePicture);
<font color="#000080"><i>{$I-}
  </i></font>Reset(FileHeader);
<font color="#000080"><i>{$I+}
  </i></font><b>if </b>IORESULT &lt;&gt; <font color="#000080">0 </font><b>then
  begin
    </b>CloseFile(FileHeader);
    Exit;
  <b>end</b>;
  Read(FileHeader, HeaderPicture);
  CloseFile(FileHeader);

  FName := HeaderPicture.Name;
  FFileName := HeaderPicture.FilePicture;
  FPatternWidth := HeaderPicture.PatternWidth;
  FPatternHeight := HeaderPicture.PatternHeight;
  FSkipWidth := HeaderPicture.SkipWidth;
  FSkipHeight := HeaderPicture.SkipHeight;
  FTransparentColor := HeaderPicture.TransparentColor;

  SetFileName(FFileName);
<b>end</b>;

<b>function </b>TPicture.SaveToFile(<b>const </b>FilePicture: <b>string</b>): Boolean;
<b>var
  </b>FileHeader: <b>file of </b>THeaderPicture;
  HeaderPicture: THeaderPicture;
<b>begin
  if </b>Length(FilePicture) = <font color="#000080">0 </font><b>then
    </b>Exit;

  AssignFile(FileHeader, FilePicture);
  <b>if </b>FileExists(FilePicture) <b>then
    </b>Reset(FileHeader)
  <b>else
    </b>Rewrite(FileHeader);

  HeaderPicture.Name := FName;
  HeaderPicture.FilePicture := FFileName;
  HeaderPicture.PatternWidth := FPatternWidth;
  HeaderPicture.PatternHeight := FPatternHeight;
  HeaderPicture.SkipWidth := FSkipWidth;
  HeaderPicture.SkipHeight := FSkipHeight;
  HeaderPicture.TransparentColor := FTransparentColor;

  Write(FileHeader, HeaderPicture);
  CloseFile(FileHeader);
<b>end</b>;

<b>function </b>TPictures.IndexOf(Name: <b>string</b>): TPicture;
<b>var
  </b>I: Integer;
<b>begin
  for </b>I := <font color="#000080">0 </font><b>to </b>Count - <font color="#000080">1 </font><b>do
  begin
    if </b>GetItem(I).Name = Name <b>then
    begin
      </b>Result := GetItem(I);
      Exit;
    <b>end</b>;
  <b>end</b>;

  Result := <b>nil</b>;
<b>end</b>;

<b>function </b>TPictures.GetItem(Index: Integer): TPicture;
<b>begin
  </b>Result := <b>inherited </b>Items[Index] <b>as </b>TPicture;
<b>end</b>;

<b>function </b>TPictures.Add: TPicture;
<b>begin
  </b>Result := <b>inherited </b>Add <b>as </b>TPicture;
<b>end</b>;

<b>function </b>TPictures.AddEx(FileName: <b>string</b>; Name: <b>string</b>; PatternWidth, PatternHeight: Integer;
  ColorKey: Longint; SkipWidth: Integer = <font color="#000080">0</font>; SkipHeight: Integer = <font color="#000080">0</font>): TPicture;
<b>begin
  </b>Result := <b>inherited </b>Add <b>as </b>TPicture;

  Result.Name := Name;
  Result.PatternWidth := PatternWidth;
  Result.PatternHeight := PatternHeight;
  Result.SkipWidth := SkipWidth;
  Result.SkipHeight := SkipHeight;
  Result.TransparentColor := ColorKey;

  Result.FileName := FileName;
<b>end</b>;

<b>function </b>TPictures.Find(<b>const </b>Name: <b>string</b>): TPicture;
<b>begin
  </b>Result := IndexOf(Name);
  <b>if </b>Result = <b>nil then
    raise </b>EError.Create(Format(ERROR_NOTFOUND, [Name]));
<b>end</b>;

<b>procedure </b>TButton.DoMouseEnter;
<b>begin
  </b>Style := <font color="#000080">1</font>;
<b>end</b>;

<b>procedure </b>TButton.DoMouseLeave;
<b>begin
  </b>Style := <font color="#000080">0</font>;
<b>end</b>;

<b>procedure </b>TButton.DoDraw;
<b>begin
  if </b>(Clicked) <b>and </b>(MouseIn) <b>then
    </b>DrawButton(Left, Top, Width, Height, <font color="#000080">2</font>, <font color="#000080">'Teste'</font>)
  <b>else
    </b>DrawButton(Left, Top, Width, Height, Style, <font color="#000080">'Teste'</font>)
<b>end</b>;

<b>end</b>.

</font>
</code></pre>
</body>
</html>
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue128;\red0\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title brControls.rtf}}

\deflang1033\pard\plain\f0\fs20 \cf0\i (*******************************************************)
\par (*                                                     *)
\par (*       Engine Paulovich DirectX                      *)
\par (*       Win32-DirectX API Unit                        *)
\par (*                                                     *)
\par (*       Copyright (c) 2003-2004, Ivan Paulovich       *)
\par (*                                                     *)
\par (*       iskatrek@hotmail.com  uin#89160524            *)
\par (*                                                     *)
\par (*       Unit: brControls                              *)
\par (*                                                     *)
\par (*******************************************************)
\par 
\par \i0\cf1\b unit \b0 brControls;
\par 
\par \b interface
\par 
\par uses
\par   \b0 Windows, Messages, SysUtils, Classes, brUtils;
\par 
\par \b type
\par 
\par   \b0\cf0\i (* Eventos *)
\par 
\par   \i0\cf1 TMouseButton = (mbLeft, mbRight, mbMiddle);
\par   TShiftState = \b set of \b0 (ssShift, ssAlt, ssCtrl,
\par     ssLeft, ssRight, ssMiddle, ssDouble);
\par   TNotifyEvent = \b procedure\b0 (Sender: TObject) \b of object\b0 ;
\par   TCommandEvent = \b procedure\b0 (Sender: TObject; ID: Integer) \b of object\b0 ;
\par   TMouseEvent = \b procedure\b0 (Sender: TObject; Button: TMouseButton;
\par     Shift: TShiftState; X, Y: Integer) \b of object\b0 ;
\par   TMouseMoveEvent = \b procedure\b0 (Sender: TObject; Shift: TShiftState;
\par     X, Y: Integer) \b of object\b0 ;
\par   TKeyEvent = \b procedure\b0 (Sender: TObject; \b var \b0 Key: Word;
\par     Shift: TShiftState) \b of object\b0 ;
\par   TKeyPressEvent = \b procedure\b0 (Sender: TObject; \b var \b0 Key: Char) \b of object\b0 ;
\par 
\par   PControl = ^TControl;
\par   TControl = \b class
\par   private
\par     \b0 FOnCreate: TNotifyEvent;
\par     FOnInitialize: TNotifyEvent;
\par     FOnFinalize: TNotifyEvent;
\par     FOnResize: TNotifyEvent;
\par     FOnClick: TNotifyEvent;
\par     FOnDblClick: TNotifyEvent;
\par     FOnMouseDown: TMouseEvent;
\par     FOnMouseMove: TMouseMoveEvent;
\par     FOnMouseUp: TMouseEvent;
\par     FOnKeyDown: TKeyEvent;
\par     FOnKeyPress: TKeyPressEvent;
\par     FOnKeyUp: TKeyEvent;
\par     FOnMouseEnter: TNotifyEvent;
\par     FOnMouseLeave: TNotifyEvent;
\par   \b protected
\par     procedure \b0 SetWidth(Value: Integer); \b virtual\b0 ;
\par     \b procedure \b0 SetHeight(Value: Integer); \b virtual\b0 ;
\par     \b procedure \b0 SetLeft(Value: Integer); \b virtual\b0 ;
\par     \b procedure \b0 SetTop(Value: Integer); \b virtual\b0 ;
\par   \b public
\par     \b0 Clicked: Boolean;
\par     ClientRect: TRect;
\par     MouseIn: Boolean;
\par     \b constructor \b0 Create; \b virtual\b0 ;
\par     \b procedure \b0 MouseDown(\b var Message\b0 : TWMMouse; Button: TMouseButton;
\par       Shift: TShiftState);
\par     \b procedure \b0 MouseMove(\b var Message\b0 : TWMMouse);
\par     \b procedure \b0 MouseUp(\b var Message\b0 : TWMMouse; Button: TMouseButton);
\par     \b function \b0 KeyDown(\b var Message\b0 : TWMKey): Boolean;
\par     \b function \b0 KeyPress(\b var Message\b0 : TWMKey): Boolean;
\par     \b function \b0 KeyUp(\b var Message\b0 : TWMKey): Boolean;
\par     \b procedure \b0 DoCreate; \b virtual\b0 ;
\par     \b procedure \b0 DoInitialize; \b virtual\b0 ;
\par     \b procedure \b0 DoFinalize; \b virtual\b0 ;
\par     \b procedure \b0 DoResize; \b virtual\b0 ;
\par     \b procedure \b0 DoClick; \b virtual\b0 ;
\par     \b procedure \b0 DoDblClick; \b virtual\b0 ;
\par     \b procedure \b0 DoMouseDown(Button: TMouseButton; Shift: TShiftState;
\par       X, Y: Integer); \b virtual\b0 ;
\par     \b procedure \b0 DoMouseMove(Shift: TShiftState; X, Y: Integer); \b virtual\b0 ;
\par     \b procedure \b0 DoMouseUp(Button: TMouseButton; Shift: TShiftState;
\par       X, Y: Integer); \b virtual\b0 ;
\par     \b procedure \b0 DoKeyDown(\b var \b0 Key: Word; Shift: TShiftState); \b virtual\b0 ;
\par     \b procedure \b0 DoKeyPress(\b var \b0 Key: Char); \b virtual\b0 ;
\par     \b procedure \b0 DoKeyUp(\b var \b0 Key: Word; Shift: TShiftState); \b virtual\b0 ;
\par     \b procedure \b0 DoMouseEnter; \b virtual\b0 ;
\par     \b procedure \b0 DoMouseLeave; \b virtual\b0 ;
\par     \b property \b0 Left: Integer \b read \b0 ClientRect.Left \b write \b0 SetLeft;
\par     \b property \b0 Top: Integer \b read \b0 ClientRect.Top \b write \b0 SetTop;
\par     \b property \b0 Width: Integer \b read \b0 ClientRect.Right \b write \b0 SetWidth;
\par     \b property \b0 Height: Integer \b read \b0 ClientRect.Bottom \b write \b0 SetHeight;
\par     \b property \b0 OnCreate: TNotifyEvent \b read \b0 FOnCreate \b write \b0 FOnCreate;
\par     \b property \b0 OnInitialize: TNotifyEvent \b read \b0 FOnInitialize \b write \b0 FOnInitialize;
\par     \b property \b0 OnFinalize: TNotifyEvent \b read \b0 FOnFinalize \b write \b0 FOnFinalize;
\par     \b property \b0 OnClick: TNotifyEvent \b read \b0 FOnClick \b write \b0 FOnClick;
\par     \b property \b0 OnDblClick: TNotifyEvent \b read \b0 FOnDblClick \b write \b0 FOnDblClick;
\par     \b property \b0 OnMouseDown: TMouseEvent \b read \b0 FOnMouseDown \b write \b0 FOnMouseDown;
\par     \b property \b0 OnMouseMove: TMouseMoveEvent \b read \b0 FOnMouseMove \b write \b0 FOnMouseMove;
\par     \b property \b0 OnMouseUp: TMouseEvent \b read \b0 FOnMouseUp \b write \b0 FOnMouseUp;
\par     \b property \b0 OnKeyDown: TKeyEvent \b read \b0 FOnKeyDown \b write \b0 FOnKeyDown;
\par     \b property \b0 OnKeyPress: TKeyPressEvent \b read \b0 FOnKeyPress \b write \b0 FOnKeyPress;
\par     \b property \b0 OnKeyUp: TKeyEvent \b read \b0 FOnKeyUp \b write \b0 FOnKeyUp;
\par     \b property \b0 OnMouseEnter: TNotifyEvent \b read \b0 FOnMouseEnter \b write \b0 FOnMouseEnter;
\par     \b property \b0 OnMouseLeave: TNotifyEvent \b read \b0 FOnMouseLeave \b write \b0 FOnMouseLeave;
\par   \b end\b0 ;
\par 
\par \b function \b0 KeysToShiftState(Keys: Word): TShiftState;
\par \b function \b0 KeyDataToShiftState(KeyData: Longint): TShiftState;
\par 
\par \b var
\par   \b0 ControlList: TList;
\par 
\par \b implementation
\par 
\par function \b0 KeysToShiftState(Keys: Word): TShiftState;
\par \b begin
\par   \b0 Result := [];
\par   \b if \b0 Keys \b and \b0 MK_SHIFT <> \cf0 0 \cf1\b then \b0 Include(Result, ssShift);
\par   \b if \b0 Keys \b and \b0 MK_CONTROL <> \cf0 0 \cf1\b then \b0 Include(Result, ssCtrl);
\par   \b if \b0 Keys \b and \b0 MK_LBUTTON <> \cf0 0 \cf1\b then \b0 Include(Result, ssLeft);
\par   \b if \b0 Keys \b and \b0 MK_RBUTTON <> \cf0 0 \cf1\b then \b0 Include(Result, ssRight);
\par   \b if \b0 Keys \b and \b0 MK_MBUTTON <> \cf0 0 \cf1\b then \b0 Include(Result, ssMiddle);
\par   \b if \b0 GetKeyState(VK_MENU) < \cf0 0 \cf1\b then \b0 Include(Result, ssAlt);
\par \b end\b0 ;
\par 
\par \b function \b0 KeyDataToShiftState(KeyData: Longint): TShiftState;
\par \b const
\par   \b0 AltMask = \cf0 $20000000\cf1 ;
\par \b begin
\par   \b0 Result := [];
\par   \b if \b0 GetKeyState(VK_SHIFT) < \cf0 0 \cf1\b then \b0 Include(Result, ssShift);
\par   \b if \b0 GetKeyState(VK_CONTROL) < \cf0 0 \cf1\b then \b0 Include(Result, ssCtrl);
\par   \b if \b0 KeyData \b and \b0 AltMask <> \cf0 0 \cf1\b then \b0 Include(Result, ssAlt);
\par \b end\b0 ;
\par 
\par \b constructor \b0 TControl.Create;
\par \b begin
\par   \b0 ControlList.Add(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.MouseDown(\b var Message\b0 : TWMMouse; Button: TMouseButton;
\par   Shift: TShiftState);
\par \b begin
\par   with Message do
\par     if \b0 PointInRect(Point(XPos, YPos), Bounds(Left, Top, Width, Height)) \b then
\par     begin
\par       \b0 Clicked := True;
\par       DoMouseDown(Button, KeysToShiftState(Keys) + Shift, XPos, YPos);
\par       DoClick;
\par     \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.MouseMove(\b var Message\b0 : TWMMouse);
\par \b begin
\par   with Message do
\par     if \b0 PointInRect(Point(XPos, YPos), Bounds(Left, Top, Width, Height)) \b then
\par     begin
\par       \b0 DoMouseMove(KeysToShiftState(Keys), XPos, YPos);
\par       \b if not \b0 MouseIn \b then
\par         \b0 DoMouseEnter;
\par       MouseIn := True;
\par     \b end
\par     else
\par     begin
\par       if \b0 MouseIn \b then
\par         \b0 DoMouseLeave;
\par       MouseIn := False;
\par     \b end\b0 ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.MouseUp(\b var Message\b0 : TWMMouse; Button: TMouseButton);
\par \b begin
\par   with Message do
\par     if \b0 PointInRect(Point(XPos, YPos), Bounds(Left, Top, Width, Height)) \b then
\par       \b0 DoMouseUp(Button, KeysToShiftState(Keys), XPos, YPos);
\par   Clicked := False;
\par \b end\b0 ;
\par 
\par \b function \b0 TControl.KeyDown(\b var Message\b0 : TWMKey): Boolean;
\par \b var
\par   \b0 ShiftState: TShiftState;
\par \b begin
\par   with Message do
\par   begin
\par     \b0 ShiftState := KeyDataToShiftState(KeyData);
\par     DoKeyDown(CharCode, ShiftState);
\par   \b end\b0 ;
\par   Result := \b Message\b0 .CharCode <> \cf0 0\cf1 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TControl.KeyPress(\b var Message\b0 : TWMKey): Boolean;
\par \b var
\par   \b0 Ch: Char;
\par \b begin
\par   with Message do
\par   begin
\par     \b0 Ch := Char(CharCode);
\par     DoKeyPress(Ch);
\par     CharCode := Word(Ch);
\par   \b end\b0 ;
\par   Result := Char(\b Message\b0 .CharCode) <> \cf0 #0\cf1 ;
\par \b end\b0 ;
\par 
\par \b function \b0 TControl.KeyUp(\b var Message\b0 : TWMKey): Boolean;
\par \b var
\par   \b0 ShiftState: TShiftState;
\par \b begin
\par   with Message do
\par   begin
\par     \b0 ShiftState := KeyDataToShiftState(KeyData);
\par     DoKeyUp(CharCode, ShiftState);
\par   \b end\b0 ;
\par   Result := \b Message\b0 .CharCode <> \cf0 0\cf1 ;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoCreate;
\par \b begin
\par   if \b0 Assigned(FOnCreate) \b then \b0 FOnCreate(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoInitialize;
\par \b begin
\par   if \b0 Assigned(FOnInitialize) \b then \b0 FOnInitialize(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoFinalize;
\par \b begin
\par   if \b0 Assigned(FOnFinalize) \b then \b0 FOnFinalize(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoResize;
\par \b begin
\par   if \b0 Assigned(FOnResize) \b then \b0 FOnResize(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoClick;
\par \b begin
\par   if \b0 Assigned(FOnClick) \b then \b0 FOnClick(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoDblClick;
\par \b begin
\par   if \b0 Assigned(FOnDblClick) \b then \b0 FOnDblClick(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoMouseDown(Button: TMouseButton; Shift: TShiftState; X,
\par   Y: Integer);
\par \b begin
\par   if \b0 Assigned(FOnMouseDown) \b then \b0 FOnMouseDown(Self, Button, Shift, Left, Top);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoMouseMove(Shift: TShiftState; X, Y: Integer);
\par \b begin
\par   if \b0 Assigned(FOnMouseMove) \b then \b0 FOnMouseMove(Self, Shift, Left, Top);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoMouseUp(Button: TMouseButton; Shift: TShiftState; X,
\par   Y: Integer);
\par \b begin
\par   if \b0 Assigned(FOnMouseUp) \b then \b0 FOnMouseUp(Self, Button, Shift, Left, Top);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoKeyDown(\b var \b0 Key: Word; Shift: TShiftState);
\par \b begin
\par   if \b0 Assigned(FOnKeyDown) \b then \b0 FOnKeyDown(Self, Key, Shift);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoKeyPress(\b var \b0 Key: Char);
\par \b begin
\par   if \b0 Assigned(FOnKeyPress) \b then \b0 FOnKeyPress(Self, Key);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoKeyUp(\b var \b0 Key: Word; Shift: TShiftState);
\par \b begin
\par   if \b0 Assigned(FOnKeyUp) \b then \b0 FOnKeyUp(Self, Key, Shift);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoMouseEnter;
\par \b begin
\par   if \b0 Assigned(FOnMouseEnter) \b then \b0 FOnMouseEnter(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.DoMouseLeave;
\par \b begin
\par   if \b0 Assigned(FOnMouseLeave) \b then \b0 FOnMouseLeave(Self);
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.SetWidth(Value: Integer);
\par \b begin
\par   \b0 ClientRect.Right := Value;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.SetHeight(Value: Integer);
\par \b begin
\par   \b0 ClientRect.Bottom := Value;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.SetLeft(Value: Integer);
\par \b begin
\par   \b0 ClientRect.Left := Value;
\par \b end\b0 ;
\par 
\par \b procedure \b0 TControl.SetTop(Value: Integer);
\par \b begin
\par   \b0 ClientRect.Top := Value;
\par \b end\b0 ;
\par 
\par \b initialization
\par   \b0 ControlList := TList.Create;
\par 
\par \b end\b0 .
\par 
\par }